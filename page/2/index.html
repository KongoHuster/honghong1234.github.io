<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>浮生若梦</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="浮生若梦">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="浮生若梦">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="浮生若梦">
  
    <link rel="alternate" href="/atom.xml" title="浮生若梦" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">浮生若梦</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-第十章异常处理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/22/第十章异常处理/" class="article-date">
  <time datetime="2019-03-22T01:06:42.000Z" itemprop="datePublished">2019-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="第十章-异常处理"><a href="#第十章-异常处理" class="headerlink" title="第十章 异常处理"></a>第十章 异常处理</h2><h3 id="一、使用try…catch捕获异常"><a href="#一、使用try…catch捕获异常" class="headerlink" title="一、使用try…catch捕获异常"></a>一、使用try…catch捕获异常</h3><ul>
<li>执行try块里的业务逻辑代码时出现异常，系统自动生成一个异常对象，该异常对象被提交给Java运行时环境，这个过程被称为抛出（throw）异常。</li>
<li>Java运行时环境收到异常对象时，会寻找能处理该异常对象的catch块，如果找到合适的catch块并把该异常对象交给该catch块处理。</li>
</ul>
<h3 id="二、异常处理"><a href="#二、异常处理" class="headerlink" title="二、异常处理"></a>二、异常处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">	需要检测的代码；</span><br><span class="line">&#125;</span><br><span class="line">catch(异常类  变量)</span><br><span class="line">&#123;</span><br><span class="line">	异常处理代码；</span><br><span class="line">&#125;</span><br><span class="line">finally</span><br><span class="line">&#123;</span><br><span class="line">	一定会执行的代码；	</span><br><span class="line">&#125;</span><br><span class="line">Finally代码块只有一种情况不会被执行。就是在之前执行了System.exit(0)。</span><br></pre></td></tr></table></figure>
<ul>
<li>资源回收<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">程序在try块里打开了一些物理资源（例如数据库连接、网络连接和磁盘文件等），这些物理资源都必须显式回收。 </span><br><span class="line"></span><br><span class="line">为了保证一定能回收try块中打开的物理资源，异常处理机制提供了finally块。不管try块中的代码是否出现异常，也不管哪一个catch块被执行，finally块总会被执。</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/22/第十章异常处理/" data-id="cjtjd6px3002an8ocgwyupryv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-对分课堂阅读笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/22/对分课堂阅读笔记/" class="article-date">
  <time datetime="2019-03-22T01:06:41.000Z" itemprop="datePublished">2019-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="对分课堂阅读笔记"><a href="#对分课堂阅读笔记" class="headerlink" title="对分课堂阅读笔记"></a>对分课堂阅读笔记</h1><p>[TOC]</p>
<h2 id="《对分课堂-大学课堂教学改革的新探索》阅读"><a href="#《对分课堂-大学课堂教学改革的新探索》阅读" class="headerlink" title="《对分课堂:大学课堂教学改革的新探索》阅读"></a>《对分课堂:大学课堂教学改革的新探索》阅读</h2><h3 id="一、对分课堂的提出前提"><a href="#一、对分课堂的提出前提" class="headerlink" title="一、对分课堂的提出前提"></a>一、对分课堂的提出前提</h3><ul>
<li>招生规模扩大，教育质量降低，高校课堂缺课率高，教学目标无法完成</li>
<li>大学课堂常常连续两节或三节，对于成长在信息 碎片化时代的学生，长时间保持对教师的注意比较困难。</li>
<li>传统教学包括教师课堂讲授和学生课 后 学 习 两 个 分 离 的 过 程 ，师 生 交 互 很 少 ，学 生 被 动 接 受，主动性低，难以培养思维能力和探索精神。</li>
<li>结合传统课堂与讨论式课堂各自的优势，进行取 舍折中，我们提出了一个新的课堂教学模式，称为“对 分课堂”。对分课堂的核心理念是把一半课堂时间分 配给教师进行讲授，另一半分配给学生以讨论的形式 进行交互式学习。类似传统课堂，对分课堂强调先教 后 学 ，教 师 讲 授 在 先 ，学 生 学 习 在 后 。</li>
</ul>
<h3 id="二、对分课堂实践"><a href="#二、对分课堂实践" class="headerlink" title="二、对分课堂实践"></a>二、对分课堂实践</h3><h4 id="1-课程及班级概况"><a href="#1-课程及班级概况" class="headerlink" title="1 课程及班级概况"></a>1 课程及班级概况</h4><ul>
<li>该班学生25人， 采用英文原版教材中译本，每周上课一次，连续3节， 每节45分钟。实际上课16周，前12周学习教科书的12 个章节，随后3周阅读文献，最后1周学生自选文献做简 短汇报。</li>
<li>第1周3节课由教师讲授第1、第2章内容，要求 学生认真听讲，课后自主阅读、学习两章内容，写出读 书笔记；</li>
<li>第2周上课前作为作业提交。第2周第1节课，学 生4人一组开展讨论，温习课本内容、分享学习体会、互 相解答疑难，并尝试回答教科书章节后面的复习题。第 2节课前半节，教师与学生互动讨论，对学生存在的疑 难进行解答，展示、点评优秀读书笔记。</li>
<li>第3到 第11周的模式与第2周类似，都是前一半时间，学生讨 论 上 周 讲 授 内 容 ，后 一 半 时 间 ，教 师 讲 授 下 一 章 节 内 容。从第12周起由教科书过渡到文献，除文献材料由 教师选定、学生不再提交作业外，基本模式类似。</li>
</ul>
<h4 id="2-课程末期结果反馈"><a href="#2-课程末期结果反馈" class="headerlink" title="2 课程末期结果反馈"></a>2 课程末期结果反馈</h4><ul>
<li>复旦课程的问卷包括 20道题，多数问询学生对特定教学环节预期目标的认 可度和该目标的实际达成度。</li>
<li>研究方法课中77.3%的学生对自己在对 分课堂中的学习效果表示满意，91%的人认为学习负 担比较合适或较轻。与传统课堂相比，86.4%的学生认 为对分课堂很好或较好。口语课中的相应比例为 68.9%，81.5%，81.6%。</li>
<li>这些基于学生自我报告的结果 表明，对分课堂在保持适度学习负担的情况下，获得 了良好的教学效果，得到大多数学生的认可。</li>
</ul>
<h3 id="三、对分课堂的合理性"><a href="#三、对分课堂的合理性" class="headerlink" title="三、对分课堂的合理性"></a>三、对分课堂的合理性</h3><ul>
<li>增强学生学习主动性</li>
<li>减轻教师负担，实现教师角色转型</li>
<li>增加生生、师生互动交流</li>
<li>提升考评准确度，关注学生学习需求</li>
<li>提升学习效果</li>
</ul>
<h3 id="四、结论"><a href="#四、结论" class="headerlink" title="四、结论"></a>四、结论</h3><ul>
<li>教学模式的改变，必然带来学习方式的改变，也 要求考核方式做相应的调整。对分课堂增加平时考 核，把学习分散到整个学期，体现了过程性评价。</li>
<li>对分课堂的出发点是调动学生的学习积极性。</li>
<li>对分课堂保留教师讲授这一传统教学的精华，保 证了知识传递的系统性、准确性和有效性。</li>
<li>教师虽然讲得少了，但其地位和价值不但没有削 弱，反而得到进一步的提升，更能赢得学生的尊重。</li>
<li>对分课堂是否适合中小学教学 也值得探索。</li>
</ul>
<h2 id="“对分课堂”的心理学原理、实施方法与效果评估"><a href="#“对分课堂”的心理学原理、实施方法与效果评估" class="headerlink" title="“对分课堂”的心理学原理、实施方法与效果评估"></a>“对分课堂”的心理学原理、实施方法与效果评估</h2><h3 id="一、最初想法"><a href="#一、最初想法" class="headerlink" title="一、最初想法"></a>一、最初想法</h3><ul>
<li>学生为分数而学，不考就不学</li>
<li>满堂讲，讲完走人</li>
<li>自己觉得很不满意:教学不应该是这样的</li>
</ul>
<h3 id="二、对比"><a href="#二、对比" class="headerlink" title="二、对比"></a>二、对比</h3><ul>
<li>翻转课堂从起步到流行10年历程</li>
<li>慕课的漫长孕育</li>
<li>从目前情况看，对分课堂的传播速度有可能会<br>远远快于翻转课堂和慕课</li>
<li><p>切入点不同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">翻转课堂:学生课下观看讲课视频，代替教师讲授，课 上做作业、讨论</span><br><span class="line"></span><br><span class="line">慕课:大规模网络授课，降低教育成本，共享资源</span><br><span class="line"></span><br><span class="line">对分课堂：不用互联网、视频等高新技术、深入分析学生学习的心理过程</span><br></pre></td></tr></table></figure>
</li>
<li><p>对分课堂不同于翻转课堂</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">先教后学与先学后教</span><br><span class="line">  对分:保留教师面授这一传统教学的精华，保证了知识传递的系统性、准确</span><br><span class="line">性和有效性</span><br><span class="line"></span><br><span class="line">心理学原理运用的深度</span><br><span class="line"> 对分:符合个体知识获取的认知心理规律</span><br><span class="line"> 翻转过分强调讨论，适合小班，不适合大班，适合训练有素的老师，适合外</span><br><span class="line">向性学生</span><br><span class="line"></span><br><span class="line">不要视频与要视频</span><br><span class="line"> 对分:注重教学流程的改革，无需大量投入，经济、实用 </span><br><span class="line"> 疑问:视频多大程度上可以代替面授</span><br></pre></td></tr></table></figure>
<h2 id="理解与建议"><a href="#理解与建议" class="headerlink" title="理解与建议"></a>理解与建议</h2><h3 id="一、小结"><a href="#一、小结" class="headerlink" title="一、小结"></a>一、小结</h3><p>&emsp;&emsp;仔细地阅读了对分易课堂的资料，虽然我是第一次遇见对分易课堂，但是受到了极大的冲击，觉得这种方法真的很棒，以后肯定能在各个课堂上得到广泛的应用。</p>
<p>&emsp;&emsp;第一，说一下大学整体的学习现状。从平面班来到种子班，教学方法和教学方式受到了极大的改变，原来的课堂是老师一人在讲台上讲，下面的只有几个学习特别好的在听，其他人要么在玩手机，要么在自己看自己的，极大的浪费了老师讲授这样极好的资源。我想，学生肯定是想学好的，但是在课堂上只要有一点没有跟上老师的思路，就会一差千里，学习习惯好的就会回去补，但是到了大学没有了像高中那样频繁的周考、月考，学生没有了那种课后总结复习的动力，一直是想着等到考试之前再看一遍，整体复习。这就导致了许许多多的问题，学生对于知识的掌握过于浅显，老师改卷越来越松，学生的质量渐渐下降，进入恶性循环。</p>
<p>&emsp;&emsp;第二、为什么我觉得对分易课堂可以解决这个问题？学习在于消化和吸收，如果我们在课堂中学到的知识能够讲述出来，我们就会发现自己的知识漏洞，及时查漏补缺。同时，我们在讲述的过程中，可以和别人产生思维的火花，现代社会沟通能力真的很重要，问题解决不了，很多时候是你不能有效接收别人的信息，或者是无法将自己的思考有效地传达出去，对分易课堂正好解决了这个交流的问题，让学生有了更多的主动性。</p>
<p>&emsp;&emsp;第三、说说我的担心。我觉得对分易课堂在种子班推广是比较容易的，因为种子班的同学热爱学习，学习能力强，表达能力都相当的出色，有强烈的求知欲。对分易课堂可以大大提高种子班的学习效率，减轻我们课后的学习负担。但是，如果想要将对分易课堂推广到普通班，会有比较大的阻力，以为大家已经养成了一直听老师讲授的习惯，想要在短时间改变这种习惯会比较困难，同时，许多同学都羞于表达自己的想法，讨论可能只是流于形式。但是，这种不好的习惯需要纠正，我们不能放任不管，我们应该尝试把对分易的教学形式逐渐地应用到其中去，渐渐大家的学习习惯。</p>
<h3 id="二、建议"><a href="#二、建议" class="headerlink" title="二、建议"></a>二、建议</h3><p>&emsp;&emsp;1.如果可以的话，我觉得小组讨论应该把讨论结果以提纲的形式列出来，这样方便我们归纳总结知识网络；</p>
<p>&emsp;&emsp;2.我觉得如果可以，我们还应该添加讨论汇报的流程，把自己在讨论中遇到的问题，产生的新想法和更多的人进行交流，这样就达到了小组讨论和全班讨论的结果。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/22/对分课堂阅读笔记/" data-id="cjtjd6pvr0019n8ocr2jefnxa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-第二章开始连接" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/22/第二章开始连接/" class="article-date">
  <time datetime="2019-03-22T01:06:40.000Z" itemprop="datePublished">2019-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、适配器之间的通信"><a href="#一、适配器之间的通信" class="headerlink" title="一、适配器之间的通信"></a>一、适配器之间的通信</h3><ul>
<li>发送端：将分组封装为数据帧，增加差错检测、可靠传输、留空等功能</li>
<li>接收端：完成差错检测、实施可靠传输</li>
</ul>
<h3 id="二、直接网络的研究问题"><a href="#二、直接网络的研究问题" class="headerlink" title="二、直接网络的研究问题"></a>二、直接网络的研究问题</h3><ul>
<li>编码：对发送到电缆或光纤上的比特进行编码, 使其能被接收主机所理解</li>
<li>帧定界：把物理链路上传输的比特序列描述为完整的消息，以便传送到端节点</li>
<li>差错检测</li>
<li>可靠传输</li>
<li>通信：如果链路静态共享, 很容易处理</li>
</ul>
<h3 id="三、网络硬件"><a href="#三、网络硬件" class="headerlink" title="三、网络硬件"></a>三、网络硬件</h3><h4 id="1-节点"><a href="#1-节点" class="headerlink" title="1.节点"></a>1.节点</h4><ul>
<li>网络中的两种稀缺资源: 节点的内存及网络链路带宽</li>
<li>网络适配器是节点接入网络的专用设备</li>
</ul>
<h4 id="2-网络适配器"><a href="#2-网络适配器" class="headerlink" title="2.网络适配器"></a>2.网络适配器</h4><ul>
<li>功能<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进行串行/并行转换;</span><br><span class="line"></span><br><span class="line">对数据进行缓存;</span><br><span class="line"></span><br><span class="line">设备驱动程序（数据链路层协议）</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-链路"><a href="#3-链路" class="headerlink" title="3.链路"></a>3.链路</h4><ul>
<li>导向型媒质: 信号在固态媒质上传播, 例如同轴电缆, 光纤, 双绞线</li>
<li>非导向型媒质: 信号自由传播, 例如电磁波</li>
<li>物理媒介：有线，无线</li>
<li>链路容量（通信信道、信道容量）</li>
</ul>
<h3 id="四、编码"><a href="#四、编码" class="headerlink" title="四、编码"></a>四、编码</h3><h4 id="1-不归零-NRZ-Non-Return-to-Zero"><a href="#1-不归零-NRZ-Non-Return-to-Zero" class="headerlink" title="1.不归零 NRZ (Non-Return to Zero)"></a>1.不归零 NRZ (Non-Return to Zero)</h4><ul>
<li>问题: 连续的1s 或 0s</li>
</ul>
<p>连续的 0s可能被误认为没有信号</p>
<p>连续的 1s可能导致基线漂移</p>
<p>时钟恢复困难（同步问题）</p>
<h4 id="2-曼彻斯特编码"><a href="#2-曼彻斯特编码" class="headerlink" title="2.曼彻斯特编码"></a>2.曼彻斯特编码</h4><ul>
<li>缺点: 信号跳变速率翻倍，比特率是信号跳变速率（波特率）的一半</li>
</ul>
<h3 id="五、组帧"><a href="#五、组帧" class="headerlink" title="五、组帧"></a>五、组帧</h3><h4 id="1-帧定界问题"><a href="#1-帧定界问题" class="headerlink" title="1.帧定界问题"></a>1.帧定界问题</h4><ul>
<li>两个节点之间的数据传输以块为单位(帧)</li>
<li>能够识别数据帧的开始和结束</li>
</ul>
<h3 id="六、可靠传输"><a href="#六、可靠传输" class="headerlink" title="六、可靠传输"></a>六、可靠传输</h3><h4 id="1-停止等待协议"><a href="#1-停止等待协议" class="headerlink" title="1.停止等待协议"></a>1.停止等待协议</h4><ul>
<li><p>链路带宽利用率较低</p>
</li>
<li><p>示例 </p>
</li>
</ul>
<p>链路带宽为2 Mbps, RTT为45 ms, 数据帧大小为1.5KB<br>每一个RTT内, 发送方仅能发送一个数据帧<br>吞吐量为1500x8/0.045 = 266.7kbps</p>
<h4 id="2-连续ARQ协议"><a href="#2-连续ARQ协议" class="headerlink" title="2.连续ARQ协议"></a>2.连续ARQ协议</h4><ul>
<li><p>Go-Back-N</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一次性发送N个数据帧；</span><br><span class="line"></span><br><span class="line">如果第k个帧丢失, 对[k, k+N-1]范围内的所有帧重传。</span><br><span class="line"></span><br><span class="line">优点: 接收方不需要缓存接收到的乱序帧，确认简单</span><br><span class="line"></span><br><span class="line">缺点: 正确帧也可能被重传，效率较低</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择性重传</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">一次性发送N个数据帧；</span><br><span class="line"></span><br><span class="line">如果第k个帧丢失, 仅重传第k个帧；</span><br><span class="line"></span><br><span class="line">接收方对每一个帧进行确认。</span><br><span class="line"></span><br><span class="line">优点: 链路利用率较高</span><br><span class="line"></span><br><span class="line">缺点: 接收方更复杂</span><br></pre></td></tr></table></figure>
<h4 id="3-滑动窗口协议ARQ"><a href="#3-滑动窗口协议ARQ" class="headerlink" title="3.滑动窗口协议ARQ"></a>3.滑动窗口协议ARQ</h4><ul>
<li>发送方:发送方在未收到确认前能够发送的数据帧的最大个数</li>
</ul>
<h3 id="七、多路访问控制"><a href="#七、多路访问控制" class="headerlink" title="七、多路访问控制"></a>七、多路访问控制</h3><h4 id="1-两种类型的“链路”"><a href="#1-两种类型的“链路”" class="headerlink" title="1.两种类型的“链路”:"></a>1.两种类型的“链路”:</h4><ul>
<li>点到点链路</li>
<li>广播链路(共享的有线/无线传输媒质)</li>
</ul>
<h4 id="2-共享广播链路通信的基本问题"><a href="#2-共享广播链路通信的基本问题" class="headerlink" title="2.共享广播链路通信的基本问题"></a>2.共享广播链路通信的基本问题</h4><ul>
<li>干扰: 如果两个或多个节点同时传输</li>
<li>冲突: 如果节点同时收到两个或多个信号</li>
</ul>
<h4 id="3-基本解决方法"><a href="#3-基本解决方法" class="headerlink" title="3.基本解决方法"></a>3.基本解决方法</h4><ul>
<li>首先、寻址</li>
<li>其次，多路访问控制协议</li>
</ul>
<h4 id="4-MAC协议"><a href="#4-MAC协议" class="headerlink" title="4.MAC协议"></a>4.MAC协议</h4><ul>
<li><p>静态信道划分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在每次循环中每一个节点占用信道固定时长 (时隙, 长度 = 数据帧传输时延) </span><br><span class="line"></span><br><span class="line">将信道划分为较小的 “分片” (时隙, 频率, 编码)</span><br><span class="line"></span><br><span class="line">每一个分片被分配给某一节点专用</span><br></pre></td></tr></table></figure>
</li>
<li><p>随机接入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">不划分信道, 允许冲突发生;</span><br><span class="line">“避免” 冲突或冲突“恢复”;</span><br><span class="line">更适合于基于分组的数据通信;</span><br><span class="line">案例: Aloha, CSMA, …</span><br></pre></td></tr></table></figure>
</li>
<li><p>轮转发送</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">节点轮流发送;</span><br><span class="line">待发送数据量大的节点占用信道更长时间;</span><br><span class="line">无冲突;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="八、问题"><a href="#八、问题" class="headerlink" title="八、问题"></a>八、问题</h3><h4 id="1-已经懂了的问题"><a href="#1-已经懂了的问题" class="headerlink" title="1.已经懂了的问题"></a>1.已经懂了的问题</h4><ul>
<li><p>1.物理链路和数据链路是什么关系？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">数据链路可以粗略地理解为数据通道。物理层要为终端设备间的数据通信提供传输媒体及其</span><br><span class="line">连接.媒体是长期的,连接是有生存期的.在连接生存期内,收发两端可以进行不等的一次或多次数</span><br><span class="line">据通信.每次通信都要经过建立通信联络和拆除通信联络两过程.这种建立起来的数据收发关系就</span><br><span class="line">叫作数据链路.而在物理媒体上传输的数据难免受到各种不可靠因素的影响而产生差错,为了弥补</span><br><span class="line">物理层上的不足,为上层提供无差错的数据传输,就要能对数据进行检错和纠错.数据链路的建立,</span><br><span class="line">拆除,对数据的检错,纠错是数据链路层的基本任务.</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.检错码和纠错码的区别是什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">检错码：只检错不纠正</span><br><span class="line">纠错码：发现错误并给以纠正</span><br><span class="line">检错码：一种编码。指在传输过程中发生错误后，在接收端能自动检查并发现错误的编码。目前常用的检错码有奇偶校验码、恒比码等 检错码的两大类别:奇偶校验编码和循环冗余编码。</span><br><span class="line">纠错码(error correcting code)，在传输过程中发生错误后能在收端自行发现或纠正的码。仅用来发现错误的码一般常称为检错码。为使一种码具有检错或纠错能力，须对原码字增加多余的码元，以扩大码字之间的差别 ，即把原码字按某种规则变成有一定剩余度（见信源编码）的码字，并使每个码字的码之间有一定的关系。关系的建立称为编码。码字到达收端后，可以根据编码规则是否满足以判定有无错误。当不能满足时，按一定规则确定错误所在位置并予以纠正。纠错并恢复原码字的过程称为译码。检错码与其他手段结合使用，可以纠错。</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="3">
<li>如何理解CRC的基本工作原理?</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CRC校验原理看起来比较复杂，好难懂，因为大多数书上基本上是以二进制的多项式形式来说明的。其实很简单的问题，其根本思想就是先在要发送的帧后面附加一个数（这个就是用来校验的校验码，但要注意，这里的数也是二进制序列的，下同），生成一个新帧发送给接收端。当然，这个附加的数不是随意的，它要使所生成的新帧能与发送端和接收端共同选定的某个特定数整除（注意，这里不是直接采用二进制除法，而是采用一种称之为“模2除法”）。到达接收端后，再把接收到的新帧除以（同样采用“模2除法”）这个选定的除数。因为在发送端发送数据帧之前就已通过附加一个数，做了“去余”处理（也就已经能整除了），所以结果应该是没有余数。如果有余数，则表明该帧在传输过程中出现了差错。</span><br></pre></td></tr></table></figure>
<ul>
<li>4.如何理解滑动窗口控制机理的工作原理?<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP滑动窗口技术通过动态改变窗口大小来调节两台主机间数据传输。每个TCP/IP主机支持全双工数据传输，因此TCP有两个滑动窗口：一个用于接收数据，另一个用于发送数据。TCP使用肯定确认技术，其确认号指的是下一个所期待的字节。假定发送方设备以每一次三个数据包的方式发送数据，也就是说，窗口大小为3。发送方发送序列号为1、2、3的三个数据包，接收方设备成功接收数据包，用序列号4确认。发送方设备收到确认，继续以窗口大小3发送数据。当接收方设备要求降低或者增大网络流量时，可以对窗口大小进行减小或者增加，本例降低窗口大小为2，每一次发送两个数据包。当接收方设备要求窗口大小为0，表明接收方已经接收了全部数据，或者接收方应用程序没有时间读取数据，要求暂停发送。发送方接收到携带窗口号为0的确认，停止这一方向的数据传输。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-未理解的问题"><a href="#2-未理解的问题" class="headerlink" title="2.未理解的问题"></a>2.未理解的问题</h4><ul>
<li>1.Go-back-N和选择重传有什么相同之处，他们的最大区别在哪？</li>
<li>2.我们该如何提高停止-等待协议的效率？</li>
<li>3.NS-3我们在实验时时如何模拟现实世界多用户，多并发量的场景的？</li>
</ul>
<h3 id="九、以太网"><a href="#九、以太网" class="headerlink" title="九、以太网"></a>九、以太网</h3><h4 id="1、802-x-标准背景介绍"><a href="#1、802-x-标准背景介绍" class="headerlink" title="1、802.x 标准背景介绍"></a>1、802.x 标准背景介绍</h4><ul>
<li>IEEE 802将数据链路层功能划分为两个子层<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LLC (逻辑链路控制) 子层</span><br><span class="line">MAC (介质访问控制) 子层</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2、物理属性"><a href="#2、物理属性" class="headerlink" title="2、物理属性"></a>2、物理属性</h4><ul>
<li>不能超过四个中继器</li>
<li>一个以太网中最多容纳1024台主机</li>
<li>分类：粗缆、细缆、双绞线</li>
</ul>
<h4 id="3、Ethernet-集线器vs-Ethernet-交换机"><a href="#3、Ethernet-集线器vs-Ethernet-交换机" class="headerlink" title="3、Ethernet 集线器vs. Ethernet 交换机"></a>3、Ethernet 集线器vs. Ethernet 交换机</h4><ul>
<li><p>Ethernet 集线器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">层1设备</span><br><span class="line">简单的信号中继器</span><br><span class="line">为节点提供共享链路</span><br></pre></td></tr></table></figure>
</li>
<li><p>Ethernet Switch</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">层2设备</span><br><span class="line">识别数据帧的地址, 完成数据帧的存储转发</span><br><span class="line">为节点提供独立的链接</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="4-介质访问控制协议"><a href="#4-介质访问控制协议" class="headerlink" title="4.介质访问控制协议"></a>4.介质访问控制协议</h4><ul>
<li>帧定界</li>
<li>差错检测</li>
<li>寻址</li>
<li>多路访问控制算法</li>
</ul>
<h4 id="5-Ethernet-CSMA-CD-协议"><a href="#5-Ethernet-CSMA-CD-协议" class="headerlink" title="5.Ethernet CSMA/CD 协议"></a>5.Ethernet CSMA/CD 协议</h4><h4 id="十、无线网络"><a href="#十、无线网络" class="headerlink" title="十、无线网络"></a>十、无线网络</h4><h4 id="1-无线链路-高比特误码率"><a href="#1-无线链路-高比特误码率" class="headerlink" title="1.无线链路: 高比特误码率"></a>1.无线链路: 高比特误码率</h4><ul>
<li>电磁波的反射</li>
<li>产生多条不同长度的传播路径</li>
<li>在接收方产生模糊信号</li>
</ul>
<h4 id="2-802-11-信道与关联"><a href="#2-802-11-信道与关联" class="headerlink" title="2.802.11: 信道与关联"></a>2.802.11: 信道与关联</h4><h4 id="3-CA-冲突避免-而不是检测"><a href="#3-CA-冲突避免-而不是检测" class="headerlink" title="3. CA: 冲突避免, 而不是检测"></a>3. CA: 冲突避免, 而不是检测</h4><h4 id="4-隐藏终端问题"><a href="#4-隐藏终端问题" class="headerlink" title="4.隐藏终端问题"></a>4.隐藏终端问题</h4><ul>
<li>依赖于物理载波监听, 可能产生隐藏终端问题</li>
</ul>
<h4 id="5-暴露终端问题"><a href="#5-暴露终端问题" class="headerlink" title="5.暴露终端问题"></a>5.暴露终端问题</h4><ul>
<li>虚拟载波监听</li>
<li>RTS/CTS机制</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/22/第二章开始连接/" data-id="cjtjd6pyc002pn8oc22l1ey42" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-第一章基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/22/第一章基础/" class="article-date">
  <time datetime="2019-03-22T01:06:40.000Z" itemprop="datePublished">2019-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第一章-基础"><a href="#第一章-基础" class="headerlink" title="第一章 基础"></a>第一章 基础</h1><h2 id="一、什么是网络"><a href="#一、什么是网络" class="headerlink" title="一、什么是网络"></a>一、什么是网络</h2><h3 id="（1）-什么是网络"><a href="#（1）-什么是网络" class="headerlink" title="（1） 什么是网络"></a>（1） 什么是网络</h3><ul>
<li>将两个或多个实体连接为在一起的系统；</li>
</ul>
<h3 id="（2）计算机网络"><a href="#（2）计算机网络" class="headerlink" title="（2）计算机网络"></a>（2）计算机网络</h3><ul>
<li>自主计算机的互联集合</li>
<li>互联网是一个典型的计算机网络</li>
</ul>
<h3 id="（3）协议"><a href="#（3）协议" class="headerlink" title="（3）协议"></a>（3）协议</h3><ul>
<li>控制发送和接受信息</li>
<li>例如：TCP、IP、HTTP、Skype</li>
</ul>
<h2 id="二、如何建造计算机网络"><a href="#二、如何建造计算机网络" class="headerlink" title="二、如何建造计算机网络"></a>二、如何建造计算机网络</h2><h3 id="1-连通性"><a href="#1-连通性" class="headerlink" title="1 连通性"></a>1 连通性</h3><p>（1）链路</p>
<ul>
<li>点到点链路</li>
<li>节点：中间结点</li>
</ul>
<p>（2）交换网络<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">交换网络</span><br><span class="line"></span><br><span class="line">一种基础网络</span><br><span class="line"></span><br><span class="line">两种类型的交换网络：电路交换和分组交换</span><br></pre></td></tr></table></figure></p>
<p>（3）网络互连</p>
<ul>
<li>多个独立的网络相互连接形成互联网</li>
<li>路由器、网关：连接两个或多个网络的特殊节点</li>
</ul>
<p>（4）主机和主机的连通性</p>
<ul>
<li>直接连接或间接连接</li>
<li>网络节点的识别</li>
</ul>
<p>（5）路由</p>
<ul>
<li>如何将报文发至目的节点</li>
</ul>
<h3 id="2-可拓展的连通性"><a href="#2-可拓展的连通性" class="headerlink" title="2 可拓展的连通性"></a>2 可拓展的连通性</h3><p>（1）梅特卡夫定律</p>
<ul>
<li>是指网络价值以用户数量的平方的速度增长。 这个法则告诉我们：网络中总人数是n，网络价值是n×n=n²。</li>
</ul>
<h3 id="3-通信网络的分类"><a href="#3-通信网络的分类" class="headerlink" title="3 通信网络的分类"></a>3 通信网络的分类</h3><ul>
<li><p>交换网络（考试会考计算时间）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">电路交换--多路复用、时分复用、频分复用</span><br><span class="line">        --网络资源被分成片</span><br><span class="line">        --优点：带宽保证、通信可靠、路由机制简单、数据包结构的额外开销小</span><br><span class="line">        --缺点：浪费带宽、受限连接、连接建立延时、网络状态</span><br><span class="line">        --电话网</span><br><span class="line">        </span><br><span class="line">分组交换：数据通过离散的数据分组进行传输</span><br><span class="line">        --先把较长的报文划分较短的、固定长的数据段</span><br><span class="line">        --每个数据前添加收不构成分组</span><br><span class="line">        --统计复用</span><br><span class="line">        --实例：ip数据网</span><br><span class="line">报文交换</span><br></pre></td></tr></table></figure>
</li>
<li><p>广播网络</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">传播时延</span><br><span class="line"></span><br><span class="line">传输时延</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">排队</span><br><span class="line"></span><br><span class="line">丢包</span><br></pre></td></tr></table></figure>
<h3 id="4-通用服务"><a href="#4-通用服务" class="headerlink" title="4 通用服务"></a>4 通用服务</h3><h4 id="1-什么是通用服务"><a href="#1-什么是通用服务" class="headerlink" title="(1)什么是通用服务"></a>(1)什么是通用服务</h4><ul>
<li>一些可以被应用车农夫调用的构件</li>
</ul>
<h4 id="2-相同的通信模式"><a href="#2-相同的通信模式" class="headerlink" title="(2)相同的通信模式"></a>(2)相同的通信模式</h4><ul>
<li>请求/响应</li>
<li>消息流</li>
</ul>
<h4 id="3-三类故障"><a href="#3-三类故障" class="headerlink" title="(3)三类故障"></a>(3)三类故障</h4><ul>
<li>比特错误</li>
<li>分组丢失</li>
<li>节点宕机</li>
</ul>
<h3 id="5-分层结构中的一些基本概念"><a href="#5-分层结构中的一些基本概念" class="headerlink" title="5 分层结构中的一些基本概念"></a>5 分层结构中的一些基本概念</h3><h4 id="（1）实体"><a href="#（1）实体" class="headerlink" title="（1）实体"></a>（1）实体</h4><h4 id="（2）协议"><a href="#（2）协议" class="headerlink" title="（2）协议"></a>（2）协议</h4><ul>
<li>语法：数据与控制信息的结构或格式</li>
<li>语义：需要发出何种控制信息，完成何的种动作以及做出何种响应。</li>
<li>同步：事件实现顺序详细说明。</li>
</ul>
<h2 id="三、非常重要，但是自己已经弄懂的了问题"><a href="#三、非常重要，但是自己已经弄懂的了问题" class="headerlink" title="三、非常重要，但是自己已经弄懂的了问题"></a>三、非常重要，但是自己已经弄懂的了问题</h2><h3 id="1-电路交换的有点和缺点，以及需要辩证地理解其有缺点。"><a href="#1-电路交换的有点和缺点，以及需要辩证地理解其有缺点。" class="headerlink" title="1 电路交换的有点和缺点，以及需要辩证地理解其有缺点。"></a>1 电路交换的有点和缺点，以及需要辩证地理解其有缺点。</h3><p>答：电路交换的优点：带宽保证、通信可靠、路由机制简单、数据包结构的额外开销小。</p>
<p>缺点：浪费带宽、受限连接、连接建立延时、网络状态。</p>
<p>理解：电路交换的优缺点实质就是相互关联的，在一定的环境下，优点可能演变为缺点，缺点可能演变为优点，我们只有真正理解事物的本质，才能让事物为我们所用，取长补短。</p>
<h3 id="2-分组交换的优点和缺点，以及需要辩证地理解其有缺点。"><a href="#2-分组交换的优点和缺点，以及需要辩证地理解其有缺点。" class="headerlink" title="2 分组交换的优点和缺点，以及需要辩证地理解其有缺点。"></a>2 分组交换的优点和缺点，以及需要辩证地理解其有缺点。</h3><p>答：优点：不存在带宽浪费、多路复用技术、服务、健壮性。</p>
<p>缺点：无法保证带宽、每个分组的开销、复杂的端到端控制、时延和拥塞。</p>
<h2 id="四、自己没有弄懂的问题"><a href="#四、自己没有弄懂的问题" class="headerlink" title="四、自己没有弄懂的问题"></a>四、自己没有弄懂的问题</h2><h3 id="1-关于计算机网络应用问题，它对应着现代企业中的什么工作，下一代计算机网络会是怎样的？"><a href="#1-关于计算机网络应用问题，它对应着现代企业中的什么工作，下一代计算机网络会是怎样的？" class="headerlink" title="1 关于计算机网络应用问题，它对应着现代企业中的什么工作，下一代计算机网络会是怎样的？"></a>1 关于计算机网络应用问题，它对应着现代企业中的什么工作，下一代计算机网络会是怎样的？</h3><h3 id="2-Ipv4和Ipv6的相同和区别？"><a href="#2-Ipv4和Ipv6的相同和区别？" class="headerlink" title="2 Ipv4和Ipv6的相同和区别？"></a>2 Ipv4和Ipv6的相同和区别？</h3><h3 id="3-对于分组交换存在的丢包情况，我们在平时上网中是不是下载一个东西，在下到一半的情况下突然下载失败了，这是不是就是丢包了？如果丢包，用户层面是如何体现的？"><a href="#3-对于分组交换存在的丢包情况，我们在平时上网中是不是下载一个东西，在下到一半的情况下突然下载失败了，这是不是就是丢包了？如果丢包，用户层面是如何体现的？" class="headerlink" title="3 对于分组交换存在的丢包情况，我们在平时上网中是不是下载一个东西，在下到一半的情况下突然下载失败了，这是不是就是丢包了？如果丢包，用户层面是如何体现的？"></a>3 对于分组交换存在的丢包情况，我们在平时上网中是不是下载一个东西，在下到一半的情况下突然下载失败了，这是不是就是丢包了？如果丢包，用户层面是如何体现的？</h3><h3 id="4-对于网络7层我们在什么样的工程应用中会遇到，这7层本质是协议，还是什么，设计这么多层是否显得过于冗余？"><a href="#4-对于网络7层我们在什么样的工程应用中会遇到，这7层本质是协议，还是什么，设计这么多层是否显得过于冗余？" class="headerlink" title="4 对于网络7层我们在什么样的工程应用中会遇到，这7层本质是协议，还是什么，设计这么多层是否显得过于冗余？"></a>4 对于网络7层我们在什么样的工程应用中会遇到，这7层本质是协议，还是什么，设计这么多层是否显得过于冗余？</h3><h2 id="五、分层的协议层"><a href="#五、分层的协议层" class="headerlink" title="五、分层的协议层"></a>五、分层的协议层</h2><h3 id="一、封装"><a href="#一、封装" class="headerlink" title="一、封装"></a>一、封装</h3><ul>
<li>通过封装, 协议实体可以在分组中携带信息通告对等实体如何处理收到的分组</li>
<li>首部/尾部的加载及分-离</li>
</ul>
<h3 id="二、复用与解复用"><a href="#二、复用与解复用" class="headerlink" title="二、复用与解复用"></a>二、复用与解复用</h3><ul>
<li>复用(Multiplexing)来自源节点不同高层实体的数据，将数据解复用(Demultiplexing)至目的节点对应的高层实体</li>
<li>能够区别数据所属的高层实体需要</li>
<li>各种不同类型的解多路复用密钥</li>
<li>在接收端主机解复用：把收到的报文传送到正确的socket</li>
<li>在发送端主机采用复用：从多个得到数据，并添<br>加头部信息 (后面的分用会socket用到)</li>
</ul>
<h3 id="六、OSI七层模型"><a href="#六、OSI七层模型" class="headerlink" title="六、OSI七层模型"></a>六、OSI七层模型</h3><h4 id="1-各层功能定义"><a href="#1-各层功能定义" class="headerlink" title="1.各层功能定义"></a>1.各层功能定义</h4><ul>
<li>应用层：向终端用户提供各类应用服务, 例如: ftp, telnet</li>
<li>表示层：<br>数据结构表示, 数据格式转换(加密、压缩)</li>
<li>会话层：<br>提供会话管理, 接入控制, 数据传输同步等</li>
<li>传输层：<br>实现终端进程之间的逻辑信道</li>
<li>网络层：<br>处理分组交换网络中的路由选择</li>
<li>数据链路层：<br>收集比特流组合成帧</li>
<li>物理层：<br>处理通信链路上的原始比特流传输</li>
</ul>
<h4 id="2-传输模型"><a href="#2-传输模型" class="headerlink" title="2.传输模型"></a>2.传输模型</h4><ul>
<li>每个层次可以在数据的前后追加本层附加的数据</li>
</ul>
<h4 id="3-网络体系架构的五层模型"><a href="#3-网络体系架构的五层模型" class="headerlink" title="3. 网络体系架构的五层模型"></a>3. 网络体系架构的五层模型</h4><ul>
<li>应用进程数据先传送到应用层</li>
<li>加上应用层首部，成为应用层 PDU</li>
<li>加上运输层首部，成为运输层报文</li>
<li>加上网络层首部，成为 IP 数据报（或分组）</li>
<li>最下面的物理层把比特流传送到物理媒体</li>
</ul>
<h3 id="六、互联网的体系结构"><a href="#六、互联网的体系结构" class="headerlink" title="六、互联网的体系结构"></a>六、互联网的体系结构</h3><h4 id="1-分层结构"><a href="#1-分层结构" class="headerlink" title="1.分层结构"></a>1.分层结构</h4><ul>
<li>应用层</li>
<li>传输层：<br>进程与进程之间的消息传输, 两个主要的协议:<br>TCP (Transmission Control Protocol)<br>UDP (User Datagram Protocol) </li>
<li>IP层：<br>主机到主机的数据分组传输<br>唯一协议: IP</li>
<li>网络接入层：没有指定该层的实际细节，可以是任意一种底层网络</li>
</ul>
<h4 id="2-设计原则"><a href="#2-设计原则" class="headerlink" title="2.设计原则"></a>2.设计原则</h4><ul>
<li>沙漏模型是Internet能够快速适应用户新应用需求和网络技术更新的关键.</li>
<li>“Simple Core and Complex Host’’ Philosophy</li>
</ul>
<h4 id="3-分组交换网中时延的四个来源"><a href="#3-分组交换网中时延的四个来源" class="headerlink" title="3.分组交换网中时延的四个来源"></a>3.分组交换网中时延的四个来源</h4><ul>
<li>节点处理时延 </li>
<li>排队延时</li>
<li>传输延时</li>
<li>传播延时</li>
</ul>
<h4 id="4-网络性能-吞吐量"><a href="#4-网络性能-吞吐量" class="headerlink" title="4.网络性能: 吞吐量"></a>4.网络性能: 吞吐量</h4><ul>
<li>吞吐量: 发送者与接收者之间比特交换的速率 (比特/单位时间)</li>
<li>瞬时: 在给定时间点的速率</li>
</ul>
<h3 id="七、网络性能"><a href="#七、网络性能" class="headerlink" title="七、网络性能"></a>七、网络性能</h3><h4 id="1-链路带宽"><a href="#1-链路带宽" class="headerlink" title="1.链路带宽"></a>1.链路带宽</h4><ul>
<li>原始定义：信号的频带宽度, 用 Hertz (Hz) 表示</li>
<li>网络定义: 一段特定的时间内网络所能传送的比特数, 用<br>bits per second (bps)表示</li>
</ul>
<h4 id="2-应用性能需求"><a href="#2-应用性能需求" class="headerlink" title="2.应用性能需求"></a>2.应用性能需求</h4><ul>
<li>平均速率及突发流量</li>
<li>内存溢出导致的数据包丢弃</li>
<li>时延抖动</li>
</ul>
<h3 id="八-套接字编程"><a href="#八-套接字编程" class="headerlink" title="八.套接字编程"></a>八.套接字编程</h3><ul>
<li>Socket：一个本地的，应用程序创建的，操作系统控制的接口。</li>
<li>套接字(socket): 应用进程之间的接口，实现端到端的传输协议</li>
<li><p>Socket API类别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PF_INET : 用于互联网编程</span><br><span class="line">PF_UNIX: 用于Unix 管道编程</span><br><span class="line">PF_PACKET:直接访问网络接口 (i.e, 绕过TCP / IP协议栈)</span><br></pre></td></tr></table></figure>
</li>
<li><p>两种基本socket API分别支持两种传输服务:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SOCK_STREAM: 可靠的，字节流服务 (TCP)  SOCK_DGRAM: 非可靠的数据报服务 (UDP)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="没有懂的问题"><a href="#没有懂的问题" class="headerlink" title="没有懂的问题"></a>没有懂的问题</h3><p>1.为什么网络体系架构没有像OSI一样分为7层；</p>
<p>2.链路带宽对于吞吐量有什么影响；</p>
<p>3.对于Socket编程没有在华为组这样的使用经历，我们该怎么深入了解socket编程。</p>
<h3 id="懂了的问题"><a href="#懂了的问题" class="headerlink" title="懂了的问题"></a>懂了的问题</h3><h4 id="1-带宽与吞吐量的区别？"><a href="#1-带宽与吞吐量的区别？" class="headerlink" title="1.带宽与吞吐量的区别？"></a>1.带宽与吞吐量的区别？</h4><p>答：吞吐量和带宽是很容易搞混的一个词，两者的单位都是Mbps。先来看两者对应的英语，吞吐量：throughput；带宽：Max net bitrate。当讨论通信链路的带宽时，一般是指链路上每秒所能传送的比特数，它取决于链路时钟速率和信道编码，在计算机网络中又称为线速。可以说以太网的带宽是10Mbps。但是需要区分链路上的可用带宽（带宽）与实际链路中每秒所能传送的比特数（吞吐量）。通常更倾向于用“吞吐量”一词来表示一个系统的测试性能。这样，因为实现受各种低效率因素的影响，所以由一段带宽为10Mbps的链路连接的一对节点可能只达到2Mbps的吞吐量。这样就意味着，一个主机上的应用能够以2Mbps的速度向另外的一个主机发送数据。</p>
<h4 id="2-网络延迟是怎样产生的？"><a href="#2-网络延迟是怎样产生的？" class="headerlink" title="2.网络延迟是怎样产生的？"></a>2.网络延迟是怎样产生的？</h4><p>网络延迟 = 传输延迟 + 处理延迟 + 缓冲队列延迟</p>
<ul>
<li>1）传输延迟这个延迟很好理解，指光、电信号在有线介质上的延迟，或无线电信号在空气介质中的延迟，这种传输延迟只和光速有关、或电信号的传输速度有关，用户无法改变该延迟。对于一条选定的端对端路径，此值是恒定的。</li>
<li>2）处理延迟接收IP包，查询转发表，硬件、或软件转发，包括封装、解封装、编码、解码时间，经过设备越多，设备吞吐能力越弱（一秒可以转发多少Gb的数据），延迟越大。但对于一条选定的端对端路径，此值也是恒定的。</li>
<li>3）缓冲队列延迟当端到端的路径上，没有任何网络拥塞，缓冲队列的延迟几户为0，网络转发性能达到线速度，好像两端用一根线直连。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/22/第一章基础/" data-id="cjtjd6pyb002on8oc6x4pby4f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-第三章网络互连md" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/22/第三章网络互连md/" class="article-date">
  <time datetime="2019-03-22T01:06:39.000Z" itemprop="datePublished">2019-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、-什么是交换机"><a href="#一、-什么是交换机" class="headerlink" title="一、 什么是交换机"></a>一、 什么是交换机</h2><ul>
<li>有多个输入端和多个输出端的设备</li>
<li>可将分组或数据帧从一个输入端口传输到一个或多个输出端口</li>
</ul>
<h2 id="二、交换网络"><a href="#二、交换网络" class="headerlink" title="二、交换网络"></a>二、交换网络</h2><h3 id="1-星形拓扑优点"><a href="#1-星形拓扑优点" class="headerlink" title="1.星形拓扑优点"></a>1.星形拓扑优点</h3><ul>
<li>构建网络链接大量主机</li>
<li>构建网络覆盖大片地理区域</li>
<li>增加新主机不会影响现有主机的性能</li>
</ul>
<h3 id="2-分组交换网络分类"><a href="#2-分组交换网络分类" class="headerlink" title="2.分组交换网络分类"></a>2.分组交换网络分类</h3><ul>
<li>电话网络: 电路交换网络</li>
<li>计算机网络: 分组交换网络</li>
</ul>
<h3 id="3-交换-转发"><a href="#3-交换-转发" class="headerlink" title="3.交换/转发"></a>3.交换/转发</h3><h4 id="（1）三种方法"><a href="#（1）三种方法" class="headerlink" title="（1）三种方法"></a>（1）三种方法</h4><ul>
<li>数据报, 无连接 </li>
<li>虚电路, 面向连接（VCI 具有”链路局部作用域”, 而非全局意义<br>）</li>
<li>源路由（源节点为每一个分组提供网络交换分组时所需的路由信息<br>）</li>
</ul>
<h3 id="4-网桥和局域网交换机"><a href="#4-网桥和局域网交换机" class="headerlink" title="4.网桥和局域网交换机"></a>4.网桥和局域网交换机</h3><h4 id="（1）透明网桥"><a href="#（1）透明网桥" class="headerlink" title="（1）透明网桥"></a>（1）透明网桥</h4><ul>
<li>问题：如何自适应构造转发表?</li>
<li>动机：根据数据帧转发过程自学习构造转发表</li>
<li>解决方案：逆向学习、主机与端口的映射关系学习</li>
</ul>
<h4 id="（2）虚拟局域网-VLAN"><a href="#（2）虚拟局域网-VLAN" class="headerlink" title="（2）虚拟局域网 (VLAN)"></a>（2）虚拟局域网 (VLAN)</h4><ul>
<li>每一个虚拟局域网分配一个标识符</li>
<li>只有两个网段的标识符相同时, 才能完成数据帧的转发 </li>
</ul>
<h2 id="三、互联网络"><a href="#三、互联网络" class="headerlink" title="三、互联网络"></a>三、互联网络</h2><h3 id="1-什么是互联网"><a href="#1-什么是互联网" class="headerlink" title="1.什么是互联网?"></a>1.什么是互联网?</h3><ul>
<li>“单一”网络的互联集合</li>
<li>视为“网络的网络”: 由许多较小的网络构成</li>
<li>范例: Internet, 当今应用最为广泛的全球性互联网</li>
</ul>
<h3 id="2-服务模型"><a href="#2-服务模型" class="headerlink" title="2.服务模型"></a>2.服务模型</h3><ul>
<li>数据报的一种服务模型</li>
<li>数据流的一种服务模型</li>
</ul>
<h3 id="3-IP服务模型"><a href="#3-IP服务模型" class="headerlink" title="3. IP服务模型"></a>3. IP服务模型</h3><h4 id="分段与重组"><a href="#分段与重组" class="headerlink" title="分段与重组"></a>分段与重组</h4><ul>
<li>主机按照与之直接相连的网络的MTU发送分组</li>
<li>分段重组由目的主机完成</li>
</ul>
<h4 id="网络层的两大核心功能"><a href="#网络层的两大核心功能" class="headerlink" title="网络层的两大核心功能"></a>网络层的两大核心功能</h4><ul>
<li>转发: 将路由器输入端口收到的分组从正确的输出端口发送出去</li>
<li>路由选择: 决定分组从源节点到达目的节点的路径</li>
</ul>
<h3 id="4-全球互联网"><a href="#4-全球互联网" class="headerlink" title="4.全球互联网"></a>4.全球互联网</h3><h4 id="编址方案"><a href="#编址方案" class="headerlink" title="编址方案"></a>编址方案</h4><ul>
<li>Flat 扁平化编址方案</li>
<li>Hierarchy 层次化编址方案</li>
</ul>
<h4 id="层次化地址空间"><a href="#层次化地址空间" class="headerlink" title="层次化地址空间"></a>层次化地址空间</h4><h3 id="5-子网划分"><a href="#5-子网划分" class="headerlink" title="5.子网划分"></a>5.子网划分</h3><ul>
<li>寻址: 子网掩码</li>
<li>IP 转发</li>
</ul>
<h3 id="6-无分类路由选择"><a href="#6-无分类路由选择" class="headerlink" title="6.无分类路由选择"></a>6.无分类路由选择</h3><p>问题：IP地址固定结构的低效性</p>
<p>动机：IP地址不采用固定的分类结构</p>
<p>解决方案：CIDR 汇聚路由</p>
<h3 id="6-无分类路由选择-CIDR"><a href="#6-无分类路由选择-CIDR" class="headerlink" title="6.无分类路由选择(CIDR)"></a>6.无分类路由选择(CIDR)</h3><ul>
<li>最长前缀匹配</li>
</ul>
<h3 id="7-地址转换"><a href="#7-地址转换" class="headerlink" title="7.地址转换"></a>7.地址转换</h3><ul>
<li>ARP工作原理:ip地址到屋里地址转换的问题</li>
</ul>
<h3 id="8-动态主机配置协议-DHCP"><a href="#8-动态主机配置协议-DHCP" class="headerlink" title="8.动态主机配置协议 (DHCP)"></a>8.动态主机配置协议 (DHCP)</h3><h3 id="9-DHCP-工作原理"><a href="#9-DHCP-工作原理" class="headerlink" title="9.DHCP 工作原理"></a>9.DHCP 工作原理</h3><h3 id="10-ICMP"><a href="#10-ICMP" class="headerlink" title="10.ICMP"></a>10.ICMP</h3><ul>
<li>ICMP分组格式</li>
<li>ICMP的应用: traceroute</li>
</ul>
<h2 id="四、路由"><a href="#四、路由" class="headerlink" title="四、路由"></a>四、路由</h2><ul>
<li>路由表和转发表</li>
<li>本节讨论小到中型网络的路由选择问题, 而非整个Internet的.</li>
</ul>
<h3 id="1、用图表示网络"><a href="#1、用图表示网络" class="headerlink" title="1、用图表示网络"></a>1、用图表示网络</h3><ul>
<li>节点: 路由器</li>
<li>边: 链路</li>
<li>寻找两个节点之间较低成本的路径的问题</li>
</ul>
<h3 id="2、距离向量-RIP"><a href="#2、距离向量-RIP" class="headerlink" title="2、距离向量 (RIP)"></a>2、距离向量 (RIP)</h3><h4 id="设计选项"><a href="#设计选项" class="headerlink" title="设计选项"></a>设计选项</h4><ul>
<li>如何获得拓扑信息</li>
<li>什么时候分发拓扑信息</li>
</ul>
<h4 id="距离向量路由选择"><a href="#距离向量路由选择" class="headerlink" title="距离向量路由选择"></a>距离向量路由选择</h4><h4 id="无穷计算问题的解决方案"><a href="#无穷计算问题的解决方案" class="headerlink" title="无穷计算问题的解决方案"></a>无穷计算问题的解决方案</h4><h3 id="3、链路状态-OSPF"><a href="#3、链路状态-OSPF" class="headerlink" title="3、链路状态(OSPF)"></a>3、链路状态(OSPF)</h3><ul>
<li>可靠洪泛</li>
<li>路由计算 </li>
<li>OSPF 协议</li>
</ul>
<h3 id="4、路由评价指标"><a href="#4、路由评价指标" class="headerlink" title="4、路由评价指标"></a>4、路由评价指标</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/22/第三章网络互连md/" data-id="cjtjd6pws001vn8ocg28f1y2q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-第六章" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/22/第六章/" class="article-date">
  <time datetime="2019-03-22T01:06:39.000Z" itemprop="datePublished">2019-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、拥塞"><a href="#一、拥塞" class="headerlink" title="一、拥塞"></a>一、拥塞</h2><h4 id="1-当网络负载持续大于其承载能力则发生拥塞"><a href="#1-当网络负载持续大于其承载能力则发生拥塞" class="headerlink" title="1.当网络负载持续大于其承载能力则发生拥塞"></a>1.当网络负载持续大于其承载能力则发生拥塞</h4><h4 id="2-拥塞现象的体现"><a href="#2-拥塞现象的体现" class="headerlink" title="2.拥塞现象的体现"></a>2.拥塞现象的体现</h4><ul>
<li>持续的分组丢失</li>
<li>分组时延不断增加</li>
</ul>
<h2 id="二、资源分配"><a href="#二、资源分配" class="headerlink" title="二、资源分配"></a>二、资源分配</h2><h3 id="1-网络模型"><a href="#1-网络模型" class="headerlink" title="1. 网络模型"></a>1. 网络模型</h3><ul>
<li>分组交换网</li>
<li>无连接流</li>
<li>服务模型</li>
</ul>
<h3 id="2-资源分配性能评估指标"><a href="#2-资源分配性能评估指标" class="headerlink" title="2.资源分配性能评估指标"></a>2.资源分配性能评估指标</h3><p>能力 = 吞吐量/时延</p>
<ul>
<li>吞吐量</li>
<li>时延</li>
</ul>
<h3 id="3-拥塞控制方法分类"><a href="#3-拥塞控制方法分类" class="headerlink" title="3.拥塞控制方法分类"></a>3.拥塞控制方法分类</h3><ul>
<li>端到端拥塞控制</li>
<li>网络协助拥塞控制</li>
</ul>
<h2 id="三、排队规则"><a href="#三、排队规则" class="headerlink" title="三、排队规则"></a>三、排队规则</h2><h3 id="1-排队规则-FIFO"><a href="#1-排队规则-FIFO" class="headerlink" title="1.排队规则: FIFO"></a>1.排队规则: FIFO</h3><ul>
<li>调度算法 vs 缓存管理</li>
<li>FIFO: First-In-First-Out / FCFS : First-Come-First-Served</li>
<li>缓存管理: 分组丢弃策略</li>
</ul>
<h3 id="2-排队规则-优先调度"><a href="#2-排队规则-优先调度" class="headerlink" title="2.排队规则: 优先调度"></a>2.排队规则: 优先调度</h3><ul>
<li>优先传输高优先级队列中的分组</li>
<li>不同类型的流量具有不同的优先级</li>
</ul>
<h3 id="3-排队规则-循环调度"><a href="#3-排队规则-循环调度" class="headerlink" title="3.排队规则: 循环调度"></a>3.排队规则: 循环调度</h3><ul>
<li>分组被分成不同类别(与优先级排队一样)</li>
<li>在类之间不存在严格的服务优先级，循环调度器在这些类之间轮流提供服务。 </li>
</ul>
<h3 id="4-排队规则-加权公平排队调度"><a href="#4-排队规则-加权公平排队调度" class="headerlink" title="4.排队规则:加权公平排队调度"></a>4.排队规则:加权公平排队调度</h3><ul>
<li>分组分类，在每个类的等待区域排队, 调度器循环为各类分组提供服务</li>
<li>每个类被分配一个加权，因此每一类在任何时间间隔内可能得到不同数量的服务</li>
<li>模拟比特级的循环调度，计算每个分组的发送完毕时间Fi, 并按照Fi的先后时间发送分组</li>
</ul>
<h2 id="四、TCP-拥塞控制"><a href="#四、TCP-拥塞控制" class="headerlink" title="四、TCP 拥塞控制"></a>四、TCP 拥塞控制</h2><h3 id="1-两个基本问题"><a href="#1-两个基本问题" class="headerlink" title="1.两个基本问题"></a>1.两个基本问题</h3><ul>
<li><p>如何察觉网络拥塞?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以超时作为网络拥塞的标志</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何调整发送速率?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP维护一个CongestionWindow 变量</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-接收窗口-vs-拥塞窗口"><a href="#2-接收窗口-vs-拥塞窗口" class="headerlink" title="2.接收窗口 vs 拥塞窗口"></a>2.接收窗口 vs 拥塞窗口</h3><ul>
<li>流量控制</li>
<li>拥塞控制</li>
<li>不同的概念, 但是采用类似的机制</li>
</ul>
<h3 id="3-TCP的两种丢包"><a href="#3-TCP的两种丢包" class="headerlink" title="3.TCP的两种丢包"></a>3.TCP的两种丢包</h3><ul>
<li>超时</li>
<li>三个重复的ACK</li>
</ul>
<h3 id="4-快速重传与快速恢复"><a href="#4-快速重传与快速恢复" class="headerlink" title="4.快速重传与快速恢复"></a>4.快速重传与快速恢复</h3><h3 id="5-TCP的发展"><a href="#5-TCP的发展" class="headerlink" title="5.TCP的发展"></a>5.TCP的发展</h3><ul>
<li>基于简单滑动窗口的流量控制机制.</li>
<li>慢启动, 拥塞避免, 快速重传.</li>
<li>快速恢复.</li>
<li>对快速重传进行了修订.</li>
</ul>
<h3 id="6-拥塞避免"><a href="#6-拥塞避免" class="headerlink" title="6.拥塞避免"></a>6.拥塞避免</h3><ul>
<li>DECbit</li>
<li>RED</li>
<li>基于源</li>
</ul>
<h2 id="五、服务质量-QoS"><a href="#五、服务质量-QoS" class="headerlink" title="五、服务质量(QoS)"></a>五、服务质量(QoS)</h2><h3 id="1、应用需求"><a href="#1、应用需求" class="headerlink" title="1、应用需求"></a>1、应用需求</h3><ul>
<li>多媒体应用和服务质量</li>
<li>多媒体网络应用 </li>
<li>点播流媒体音频和视频 </li>
<li>存储式流媒体音频和视频</li>
<li>直播流媒体音频和视频</li>
</ul>
<h3 id="2-区分服务-EF、AF"><a href="#2-区分服务-EF、AF" class="headerlink" title="2.区分服务(EF、AF)"></a>2.区分服务(EF、AF)</h3><ul>
<li>提供多个服务等级</li>
<li>音频应用和FTP传输</li>
<li>区分服务(DiffServ)</li>
<li>边缘路由器分组标记</li>
<li>分类和调节</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/22/第六章/" data-id="cjtjd6px00026n8oczkr0i014" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-第五章端到端协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/22/第五章端到端协议/" class="article-date">
  <time datetime="2019-03-22T01:06:39.000Z" itemprop="datePublished">2019-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、支持通用服务"><a href="#一、支持通用服务" class="headerlink" title="一、支持通用服务"></a>一、支持通用服务</h2><ul>
<li>目标 1: 网络支持各种不同的应用 </li>
<li>目标 2: 网络在现实网络条件下支持各种不同的应用</li>
</ul>
<h2 id="二、进程间如何通信"><a href="#二、进程间如何通信" class="headerlink" title="二、进程间如何通信"></a>二、进程间如何通信</h2><h3 id="1-传输层-上层协议的观点"><a href="#1-传输层-上层协议的观点" class="headerlink" title="1.传输层: 上层协议的观点"></a>1.传输层: 上层协议的观点</h3><ul>
<li>保证消息的传输</li>
<li>传送过程中保证消息发送时的顺序</li>
<li>最多传送每个消息的一个副本</li>
<li>支持任意大的消息</li>
<li>支持发送方与接收方之间的同步</li>
<li>允许接收方对发送方进行流量控制</li>
<li>支持每台主机上的多个应用进程</li>
</ul>
<h3 id="2-传输层-下层网络的观点"><a href="#2-传输层-下层网络的观点" class="headerlink" title="2.传输层: 下层网络的观点"></a>2.传输层: 下层网络的观点</h3><ul>
<li>底层网络可以提供的服务:</li>
<li>不可靠的分组传送</li>
<li>不确定的时延</li>
<li>有限大小的分组</li>
</ul>
<h3 id="3-用户数据报协议-UDP"><a href="#3-用户数据报协议-UDP" class="headerlink" title="3.用户数据报协议(UDP)"></a>3.用户数据报协议(UDP)</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>仅在IP基础上增加了一级解多路复用功能</li>
<li>面向报文</li>
<li>无连接</li>
<li>不保证消息的可靠传送</li>
<li>无流量控制 </li>
</ul>
<h4 id="UDP的优点"><a href="#UDP的优点" class="headerlink" title="UDP的优点"></a>UDP的优点</h4><ul>
<li>控制数据发送的内容和时间</li>
<li>不存在连接建立时延</li>
<li>无状态连接</li>
<li>报文首部开销较小</li>
</ul>
<h4 id="UDP的缺点"><a href="#UDP的缺点" class="headerlink" title="UDP的缺点"></a>UDP的缺点</h4><ul>
<li>“尽最大努力交付”</li>
<li>无拥塞控制</li>
<li>抑制TCP流</li>
</ul>
<h4 id="采用UDP协议的应用"><a href="#采用UDP协议的应用" class="headerlink" title="采用UDP协议的应用"></a>采用UDP协议的应用</h4><ul>
<li>简单查询协议(例如域名解析系统, DNS)</li>
<li>多媒体应用</li>
</ul>
<h2 id="三、TCP-服务模型"><a href="#三、TCP-服务模型" class="headerlink" title="三、TCP 服务模型"></a>三、TCP 服务模型</h2><h3 id="1-TCP面临的挑战"><a href="#1-TCP面临的挑战" class="headerlink" title="1.TCP面临的挑战"></a>1.TCP面临的挑战</h3><ul>
<li>连接</li>
<li>超时重传</li>
<li>乱序到达</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
<h3 id="2-三次握手"><a href="#2-三次握手" class="headerlink" title="2.三次握手"></a>2.三次握手</h3><p>主要是为了防止已经失效的连接请求报文段又被接收方<br>收到而导致的错误</p>
<h3 id="3-TCP-滑动窗口算法"><a href="#3-TCP-滑动窗口算法" class="headerlink" title="3.TCP 滑动窗口算法"></a>3.TCP 滑动窗口算法</h3><ul>
<li>可靠有序的数据传送</li>
<li>流量控制</li>
<li>防止回绕</li>
<li>保持管道满载</li>
</ul>
<h3 id="4-TCP中的触发传输"><a href="#4-TCP中的触发传输" class="headerlink" title="4.TCP中的触发传输"></a>4.TCP中的触发传输</h3><ul>
<li>傻瓜窗口症状</li>
<li>当应用层交付数据速度较快，而网络速率较慢时，较小的报文段浪费带宽</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/22/第五章端到端协议/" data-id="cjtjd6pwz0025n8ocv0bn3xmu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-MailCore2之POP协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/22/MailCore2之POP协议/" class="article-date">
  <time datetime="2019-03-22T01:06:38.000Z" itemprop="datePublished">2019-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MailCore2之POP协议"><a href="#MailCore2之POP协议" class="headerlink" title="MailCore2之POP协议"></a>MailCore2之POP协议</h1><p>[TOC]</p>
<h3 id="1-POP协议简介"><a href="#1-POP协议简介" class="headerlink" title="1.POP协议简介"></a>1.POP协议简介</h3><p>&emsp;&emsp;POP邮局协议负责从邮件服务器中检索电子邮件。</p>
<p>&emsp;&emsp;它要求邮件服务器完成下面几种任务之一：</p>
<p>&emsp;&emsp;1. 从邮件服务器中检索邮件并从服务器中删除这个邮件；</p>
<p>&emsp;&emsp;2.从邮件服务器中检索邮件但不删除它；</p>
<p>&emsp;&emsp;3. 不检索邮件，只是询问是否有新邮件到达。</p>
<p>&emsp;&emsp;POP协议支持多用户互联网邮件扩展，后者允许用户在电子邮件上附带二进制文件，如文字处理文件和电子表格文件等，实际上这样就可以传输任何格式的文件了，包括图片和声音文件等。在用户阅读邮件时，POP命令所有的邮件信息立即下载到用户的计算机上，不在服务器上保留。</p>
<h3 id="2-各大类的分层关系"><a href="#2-各大类的分层关系" class="headerlink" title="2.各大类的分层关系"></a>2.各大类的分层关系</h3><table>
<thead>
<tr>
<th style="text-align:center"><img src="img/POP类分层.jpg" alt="普查谈话"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">图 1            POP类分层</td>
</tr>
</tbody>
</table>
<h3 id="3-POPSession"><a href="#3-POPSession" class="headerlink" title="3.POPSession"></a>3.POPSession</h3><p>POPSession主要是对用户名，端口等进行定义，初始化，获取的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//init函数包含了几乎所有的信息</span><br><span class="line">void POPSession::init()</span><br><span class="line">&#123;</span><br><span class="line">    mHostname = NULL;</span><br><span class="line">    mPort = 0;</span><br><span class="line">    mUsername = NULL;</span><br><span class="line">    mPassword = NULL;</span><br><span class="line">    mAuthType = AuthTypeSASLNone;</span><br><span class="line">    mConnectionType = ConnectionTypeClear;</span><br><span class="line">    mCheckCertificateEnabled = true;</span><br><span class="line">    mTimeout = 30;</span><br><span class="line">    </span><br><span class="line">    mPop = NULL;</span><br><span class="line">    mCapabilities = POPCapabilityNone;</span><br><span class="line">    mProgressCallback = NULL;</span><br><span class="line">    mState = STATE_DISCONNECTED;</span><br><span class="line">    mConnectionLogger = NULL;</span><br><span class="line">    pthread_mutex_init(&amp;mConnectionLoggerLock, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-POPMessageInfo"><a href="#4-POPMessageInfo" class="headerlink" title="4.POPMessageInfo"></a>4.POPMessageInfo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class MAILCORE_EXPORT POPMessageInfo : public Object &#123;</span><br><span class="line">   public:</span><br><span class="line">       POPMessageInfo();//调用init函数进行初始化，再是设置mIndex，mSize，mUid的值</span><br><span class="line">       virtual ~POPMessageInfo();// MC_SAFE_RELEASE(mUid);</span><br><span class="line">       </span><br><span class="line">       virtual void setIndex(unsigned int index);//设置 mIndex = index</span><br><span class="line">       virtual unsigned int index();</span><br><span class="line">       </span><br><span class="line">       virtual void setSize(unsigned int size);</span><br><span class="line">       virtual unsigned int size();//返回size的值</span><br><span class="line">       </span><br><span class="line">       virtual void setUid(String * uid);</span><br><span class="line">       virtual String * uid();//返回muid的值</span><br><span class="line">       </span><br><span class="line">   public: // subclass behavior</span><br><span class="line">       POPMessageInfo(POPMessageInfo * other);//返回mIndex，mSize，mUid，this的uft8值</span><br><span class="line">       virtual String * description();</span><br><span class="line">       virtual Object * copy();</span><br><span class="line">       </span><br><span class="line">   private:</span><br><span class="line">       unsigned int mIndex;</span><br><span class="line">       unsigned int mSize;</span><br><span class="line">       String * mUid;</span><br><span class="line">       </span><br><span class="line">       void init();//初始化mIndex，mSize，mUid</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/22/MailCore2之POP协议/" data-id="cjtjd6pv3000in8ocrac7cp82" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-log模块学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/22/log模块学习笔记/" class="article-date">
  <time datetime="2019-03-22T01:06:38.000Z" itemprop="datePublished">2019-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="log模块学习笔记"><a href="#log模块学习笔记" class="headerlink" title="log模块学习笔记"></a>log模块学习笔记</h1><p>[TOC]</p>
<h2 id="一-Trivial-logging"><a href="#一-Trivial-logging" class="headerlink" title="一 Trivial logging"></a>一 Trivial logging</h2><p>1.样例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;boost/log/trivial.hpp&gt;</span><br><span class="line"></span><br><span class="line">int main(int, char*[])</span><br><span class="line">&#123;</span><br><span class="line">    BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;A trace severity message&quot;;</span><br><span class="line">    BOOST_LOG_TRIVIAL(debug) &lt;&lt; &quot;A debug severity message&quot;;</span><br><span class="line">    BOOST_LOG_TRIVIAL(info) &lt;&lt; &quot;An informational severity message&quot;;</span><br><span class="line">    BOOST_LOG_TRIVIAL(warning) &lt;&lt; &quot;A warning severity message&quot;;</span><br><span class="line">    BOOST_LOG_TRIVIAL(error) &lt;&lt; &quot;An error severity message&quot;;</span><br><span class="line">    BOOST_LOG_TRIVIAL(fatal) &lt;&lt; &quot;A fatal severity message&quot;;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.注意点</p>
<ul>
<li>The BOOST_LOG_TRIVIAL macro accepts a severity level and results in a stream-like object that supports insertion operator.</li>
<li>the library offers a few advantagesthe library offers a few advantages than std::cout<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Besides the record message, each log record in the output contains a timestamp, the current thread identifier and severity level.</span><br><span class="line">2.It is safe to write logs from different threads concurrently, log messages will not be corrupted.</span><br><span class="line">3.As will be shown later, filtering can be applied.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="二-Trivial-logging-with-filters"><a href="#二-Trivial-logging-with-filters" class="headerlink" title="二 Trivial logging with filters"></a>二 Trivial logging with filters</h2><p>1.代码样例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    logging::core::get()-&gt;set_filter</span><br><span class="line">    (</span><br><span class="line">        logging::trivial::severity &gt;= logging::trivial::info</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int, char*[])</span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;A trace severity message&quot;;</span><br><span class="line">    BOOST_LOG_TRIVIAL(debug) &lt;&lt; &quot;A debug severity message&quot;;</span><br><span class="line">    BOOST_LOG_TRIVIAL(info) &lt;&lt; &quot;An informational severity message&quot;;</span><br><span class="line">    BOOST_LOG_TRIVIAL(warning) &lt;&lt; &quot;A warning severity message&quot;;</span><br><span class="line">    BOOST_LOG_TRIVIAL(error) &lt;&lt; &quot;An error severity message&quot;;</span><br><span class="line">    BOOST_LOG_TRIVIAL(fatal) &lt;&lt; &quot;A fatal severity message&quot;;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.注意点</p>
<ul>
<li><p>显示结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[2018-06-05 00:07:39.439453] [0x00007f3d06d6e740] [info]    An informational severity message</span><br><span class="line">[2018-06-05 00:07:39.439637] [0x00007f3d06d6e740] [warning] A warning severity message</span><br><span class="line">[2018-06-05 00:07:39.439680] [0x00007f3d06d6e740] [error]   An error severity message</span><br><span class="line">[2018-06-05 00:07:39.439714] [0x00007f3d06d6e740] [fatal]   A fatal severity message</span><br></pre></td></tr></table></figure>
</li>
<li><p>不能使用‘=’</p>
</li>
</ul>
<h2 id="三-Setting-up-sinks"><a href="#三-Setting-up-sinks" class="headerlink" title="三 Setting up sinks"></a>三 Setting up sinks</h2><h2 id="四-Creating-loggers-and-writing-logs"><a href="#四-Creating-loggers-and-writing-logs" class="headerlink" title="四 Creating loggers and writing logs"></a>四 Creating loggers and writing logs</h2><h3 id="1-Global-logger-objects"><a href="#1-Global-logger-objects" class="headerlink" title="1. Global logger objects"></a>1. Global logger objects</h3><p>In case you cannot put a logger into your class (suppose you don’t have one), the library provides a way of declaring global loggers like this:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOST_LOG_INLINE_GLOBAL_LOGGER_DEFAULT(my_logger, src::logger_mt)</span><br></pre></td></tr></table></figure></p>
<h3 id="2-Writing-logs"><a href="#2-Writing-logs" class="headerlink" title="2.Writing logs"></a>2.Writing logs</h3><p>No matter what kind of logger you use (class member or global, thread-safe or not), to write a log record into a logger you can write something like this:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">logging::record rec = lg.open_record();</span><br><span class="line">if (rec)</span><br><span class="line">&#123;</span><br><span class="line">    logging::record_ostream strm(rec);</span><br><span class="line">    strm &lt;&lt; &quot;Hello, World!&quot;;</span><br><span class="line">    strm.flush();</span><br><span class="line">    lg.push_record(boost::move(rec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Of course, the above syntax can easily be wrapped in a macro and, in fact, users are encouraged to write their own macros instead of using the C++ logger interface directly. The log record above can be written like this:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOST_LOG(lg) &lt;&lt; &quot;Hello, World!&quot;;</span><br></pre></td></tr></table></figure></p>
<h2 id="五-Adding-more-information-to-log-Attributes"><a href="#五-Adding-more-information-to-log-Attributes" class="headerlink" title="五 Adding more information to log: Attributes"></a>五 Adding more information to log: Attributes</h2><h3 id="1-Commonly-used-attributes"><a href="#1-Commonly-used-attributes" class="headerlink" title="1.Commonly used attributes"></a>1.Commonly used attributes</h3><p>There are attributes that are likely to be used in nearly any application. Log record counter and a time stamp are good candidates. They can be added with a single function call:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging::add_common_attributes();</span><br></pre></td></tr></table></figure></p>
<h3 id="2-Defining-attribute-placeholders"><a href="#2-Defining-attribute-placeholders" class="headerlink" title="2.Defining attribute placeholders"></a>2.Defining attribute placeholders</h3><h2 id="六-其他要点笔记"><a href="#六-其他要点笔记" class="headerlink" title="六 其他要点笔记"></a>六 其他要点笔记</h2><h4 id="1-常用的简写"><a href="#1-常用的简写" class="headerlink" title="1.常用的简写"></a>1.常用的简写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">namespace logging = boost::log;</span><br><span class="line">namespace src = boost::log::sources;</span><br><span class="line">namespace expr = boost::log::expressions;</span><br><span class="line">namespace sinks = boost::log::sinks;</span><br><span class="line">namespace attrs = boost::log::attributes;</span><br><span class="line">namespace keywords = boost::log::keywords;</span><br></pre></td></tr></table></figure>
<h4 id="2-要点"><a href="#2-要点" class="headerlink" title="2.要点"></a>2.要点</h4><ol>
<li>trivial头文件可用于一般的控制台输出，日志等级被定义在改头文件；</li>
<li>全局日志等级过滤使用logging::core::get()-&gt;set_filter();</li>
<li><p>如果不仅仅需要简单的控制台输出，这时候就要添加sink，使用logging::add_file_log可添加文件sink后端，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">logging::add_file_log (</span><br><span class="line">keywords::file_name=&quot;sample_%N.log&quot;, //文件名格式 </span><br><span class="line">keywords::rotation_size=10*1024*1024, //超过此大小自动建立新文件 </span><br><span class="line">keywords::time_based_rotation=sinks::file::rotation_at_time_point(0,0,0),//每隔指定时间重建新文件 </span><br><span class="line">keywords::format=&quot;[%TimeStamp%]:%Message%&quot; //日志消息格式 </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>除了文件后端，更常用的是文本流后端sinks::text_ostream_backend，与别的后端不同，文本流后端可以添加多个输出对象，这些对象由于都在同一个sink中，所以输出格式是一样的，这种做法的性能比添加文件后端更高，但是会失去对文件的控制能力。</p>
</li>
<li>对于大规模应用程序，为了方便查看记录，各模块的日志应该相互独立，因此一个logger一般是不够的，我们需要自己建立logger。logger的建立方法很简单，new一个src::logger就可以了…</li>
<li>attribute是log record的附加信息，不同于一般的消息记录，属性可以被单独拿出来处理，作为某种过滤条件，或者其他使用。属性分为全局属性，特定线程属性和特定源的属性。</li>
<li>格式化输出消息，前文有set_formatter的用法。格式化消息可以使用stl格式expr::stream&lt;&lt;xxx，也可以使用boost::format格式，即expr::format(“%1%)%xxx这种。</li>
</ol>
<h2 id="七-boost-filesystem常用用法详解"><a href="#七-boost-filesystem常用用法详解" class="headerlink" title="七 boost::filesystem常用用法详解"></a>七 boost::filesystem常用用法详解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;boost/filesystem.hpp&gt;   </span><br><span class="line">  </span><br><span class="line">&#123;  </span><br><span class="line">    boost::filesystem::path path(&quot;/test/test1&quot;);   //初始化   </span><br><span class="line">    boost::filesystem::path old_cpath = boost::filesystem::current_path(); //取得当前程序所在目录    </span><br><span class="line">    boost::filesystem::path parent_path = old_cpath.parent_path();//取old_cpath的上一层父目录路径   </span><br><span class="line">    boost::filesystem::path file_path = old_cpath / &quot;file&quot;; //path支持重载/运算符  </span><br><span class="line">    if(boost::filesystem::exists(file_path))  //判断文件存在性    </span><br><span class="line">    &#123;    </span><br><span class="line">        std::string strPath = file_path.string();  </span><br><span class="line">        int x = 1;  </span><br><span class="line">    &#125;   </span><br><span class="line">    else   </span><br><span class="line">    &#123;    </span><br><span class="line">        //目录不存在;     </span><br><span class="line">        boost::filesystem::create_directory(file_path);  //目录不存在，创建   </span><br><span class="line">    &#125;    </span><br><span class="line">    bool bIsDirectory = boost::filesystem::is_directory(file_path); //判断file_path是否为目录  </span><br><span class="line">    boost::filesystem::recursive_directory_iterator beg_iter(file_path);  </span><br><span class="line">    boost::filesystem::recursive_directory_iterator end_iter;  </span><br><span class="line">    for (; beg_iter != end_iter; ++beg_iter)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if (boost::filesystem::is_directory(*beg_iter))  </span><br><span class="line">        &#123;  </span><br><span class="line">            continue;  </span><br><span class="line">        &#125;  </span><br><span class="line">        else  </span><br><span class="line">        &#123;     </span><br><span class="line">            std::string strPath = beg_iter-&gt;path().string();  //遍历出来的文件名  </span><br><span class="line">            int x=1;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    boost::filesystem::path new_file_path = file_path / &quot;test.txt&quot;;  </span><br><span class="line">    if(boost::filesystem::is_regular_file(new_file_path))   //判断是否为普通文件  </span><br><span class="line">    &#123;    </span><br><span class="line">        UINT sizefile = boost::filesystem::file_size(new_file_path);  //文件大小(字节)  </span><br><span class="line">        int x =1;  </span><br><span class="line">    &#125;     </span><br><span class="line">    boost::filesystem::remove(new_file_path);//删除文件new_file_path    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="八-形象的比喻"><a href="#八-形象的比喻" class="headerlink" title="八 形象的比喻"></a>八 形象的比喻</h2><p>水 （Hello, World!）</p>
<p>水槽（sink）</p>
<p>流向哪里（console,file）</p>
<p>从哪里取（source）</p>
<p>水的等级（severity level）</p>
<p>过滤输出（filter）</p>
<p>格式输出（format）</p>
<p>各部分连接者（core）</p>
<h2 id="九-Sink-frontends"><a href="#九-Sink-frontends" class="headerlink" title="九 Sink frontends"></a>九 Sink frontends</h2><h2 id="十-Sink-backends"><a href="#十-Sink-backends" class="headerlink" title="十 Sink backends"></a>十 Sink backends</h2><p>1.With the auto_flush method one can tell the sink to automatically flush the buffers of all attached streams after each log record is written. </p>
<p>2.Text stream backend<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. It supports formatting log records into strings and putting into one or several streams. Each attached stream gets the same result of formatting, so if you </span><br><span class="line">need to format log records differently for different streams, you will need to create several sinks - each with its own formatter.</span><br><span class="line"></span><br><span class="line">2.The backend also provides a feature that may come useful when debugging your application.</span><br></pre></td></tr></table></figure></p>
<p>3.Text file backend<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. Log file rotation based on file size and/or time</span><br><span class="line"></span><br><span class="line">2.Flexible log file naming</span><br><span class="line"></span><br><span class="line">3.Placing the rotated files into a special location in the file system</span><br><span class="line"></span><br><span class="line">4.Deleting the oldest files in order to free more space on the file system</span><br></pre></td></tr></table></figure></p>
<p>4.Text multi-file backend<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You can see we used a regular formatter in order to specify file naming pattern. Now, every log record with a distinct value of the &quot;RequestID&quot; attribute will be </span><br><span class="line">stored in a separate file, no matter how many different requests are being processed by the application concurrently. You can also find the multiple_files </span><br><span class="line">example in the library distribution, which shows a similar technique to separate logs generated by different threads of the application.</span><br></pre></td></tr></table></figure></p>
<p>5.Syslog backend<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.The syslog backend, as comes from its name, provides support for the syslog API that is available on virtually any UNIX-like platform. On Windows there </span><br><span class="line">exists at least one public implementation of the syslog client API.</span><br><span class="line"></span><br><span class="line">2.The backend also supports severity level translation from the application-specific values to the syslog-defined values.</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/22/log模块学习笔记/" data-id="cjtjd6py8002nn8oc54ecge8m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Mailcore2源码阅读" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/22/Mailcore2源码阅读/" class="article-date">
  <time datetime="2019-03-22T01:06:38.000Z" itemprop="datePublished">2019-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Mailcore2-源码阅读笔记"><a href="#Mailcore2-源码阅读笔记" class="headerlink" title="Mailcore2 源码阅读笔记"></a>Mailcore2 源码阅读笔记</h1><p>[TOC]</p>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>&emsp;&emsp;MailCore是一个第三方的邮件SDK，支持POP和IMAP 方式接收邮件，以及smtp邮件发送.</p>
<h2 id="二、POP"><a href="#二、POP" class="headerlink" title="二、POP"></a>二、POP</h2><h3 id="1-需要先创建MCOPOPSession，并配置连接邮箱需要的各个参数"><a href="#1-需要先创建MCOPOPSession，并配置连接邮箱需要的各个参数" class="headerlink" title="1.需要先创建MCOPOPSession，并配置连接邮箱需要的各个参数"></a>1.需要先创建MCOPOPSession，并配置连接邮箱需要的各个参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MCOPOPSession *session = [[MCOPOPSession alloc] init];</span><br><span class="line"></span><br><span class="line">session.hostname = @&quot;pop.qq.com&quot;;</span><br><span class="line"></span><br><span class="line">session.port = 995;</span><br><span class="line"></span><br><span class="line">[session setUsername:@&quot;myMail@qq.com&quot;];</span><br><span class="line"></span><br><span class="line">[sessionsetPassword:@&quot;yourPsw&quot;];</span><br><span class="line"></span><br><span class="line">[sessionsetConnectionType:MCOConnectionTypeTLS];</span><br></pre></td></tr></table></figure>
<h3 id="2-配置好参数后，创建MCOPOPOperation，通过该对象来操作邮件"><a href="#2-配置好参数后，创建MCOPOPOperation，通过该对象来操作邮件" class="headerlink" title="2.配置好参数后，创建MCOPOPOperation，通过该对象来操作邮件"></a>2.配置好参数后，创建MCOPOPOperation，通过该对象来操作邮件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MCOPOPOperation * checkOp = [sessioncheckAccountOperation];</span><br><span class="line"></span><br><span class="line">//开启异步请求，检查目前该配置是否能正确登录邮箱</span><br><span class="line"></span><br><span class="line">[checkOp start:^(NSError *error) &#123;</span><br><span class="line">         NSLog(@&quot;finished checking account.&quot;);</span><br><span class="line">         </span><br><span class="line">         if (error == nil) &#123;</span><br><span class="line">          //正确登录邮箱</span><br><span class="line">          /*在这里获取邮件头，通过邮件头可以获得邮件内容，详情看下面*/</span><br><span class="line">         &#125; else &#123;</span><br><span class="line"></span><br><span class="line">             NSLog(@&quot;登录邮箱失败，请检查网络重试,error loading account: %@&quot;, error);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         checkOp = nil;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<h3 id="3-获取邮件头，通过MCOPOPFetchMessagesOperation来获取邮件头"><a href="#3-获取邮件头，通过MCOPOPFetchMessagesOperation来获取邮件头" class="headerlink" title="3.获取邮件头，通过MCOPOPFetchMessagesOperation来获取邮件头"></a>3.获取邮件头，通过MCOPOPFetchMessagesOperation来获取邮件头</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MCOPOPFetchMessagesOperation * op = [session fetchMessagesOperation];</span><br><span class="line"></span><br><span class="line">//异步获取邮件头MCOPOPMessageInfo，保存在messages里</span><br><span class="line"></span><br><span class="line">[op start:^(NSError * error,NSArray * messages) &#123;</span><br><span class="line"></span><br><span class="line">    if (error==nil) &#123;</span><br><span class="line"></span><br><span class="line">  //通过messages中的邮件头信息，可以进一步请求获得最终的邮件内容,获取方法见下面4</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="4-通过MCOPOPMessageInfo获取邮件内容-得到MCOMessageParser，可从中获得邮件标题，正文，附件等信息"><a href="#4-通过MCOPOPMessageInfo获取邮件内容-得到MCOMessageParser，可从中获得邮件标题，正文，附件等信息" class="headerlink" title="4.通过MCOPOPMessageInfo获取邮件内容,得到MCOMessageParser，可从中获得邮件标题，正文，附件等信息"></a>4.通过MCOPOPMessageInfo获取邮件内容,得到MCOMessageParser，可从中获得邮件标题，正文，附件等信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">MCOPOPMessageInfo *messageInfo= messages[0];//拿到一个邮件头</span><br><span class="line"></span><br><span class="line">int index= messageInfo.index;</span><br><span class="line"></span><br><span class="line">MCOPOPFetchMessageOperation*messageOperation=[session fetchMessageOperationWithIndex: index];</span><br><span class="line"></span><br><span class="line">//开启异步请求, messageData为邮件内容</span><br><span class="line"></span><br><span class="line">[messageOperation start:^(NSError * error, NSData *messageData) &#123;</span><br><span class="line"></span><br><span class="line">    // messageData is the RFC 822 formatted message data.</span><br><span class="line"></span><br><span class="line">         if (!error) &#123;</span><br><span class="line"></span><br><span class="line">    //由data转换为MCOMessageParser</span><br><span class="line"></span><br><span class="line">             MCOMessageParser * msgPaser =[MCOMessageParser messageParserWithData:messageData];</span><br><span class="line"></span><br><span class="line">    //可从msgPaser获得邮件信息，如：msgPaser.header.subject为邮件标题</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">             NSString *htmlString=[msgPaserhtmlBodyRendering];//获取邮件html正文</span><br><span class="line"></span><br><span class="line">                 messageOperation=nil;</span><br><span class="line"></span><br><span class="line">             &#125;else&#123;</span><br><span class="line"></span><br><span class="line">               </span><br><span class="line"></span><br><span class="line">                 NSLog(@&quot;获取邮件消息失败&quot;);</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;];</span><br></pre></td></tr></table></figure>
<h3 id="5-关于MCOMessageParser"><a href="#5-关于MCOMessageParser" class="headerlink" title="5.关于MCOMessageParser"></a>5.关于MCOMessageParser</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// MCOMessageHeader包含了邮件标题，时间等头信息</span><br><span class="line"></span><br><span class="line">MCOMessageHeader *header=msgPaser.header;</span><br><span class="line"></span><br><span class="line">//获得邮件正文的HTML内容,一般使用webView加载</span><br><span class="line"></span><br><span class="line">NSString * bodyHtml =[msgPaser htmlBodyRendering];</span><br><span class="line"></span><br><span class="line">//获取附件(多个)</span><br><span class="line"></span><br><span class="line">NSMutableArray *attachments=[[NSMutableArrayalloc]initWithArray:_msgPaser.attachments];</span><br><span class="line"></span><br><span class="line">MCOAttachment *attachment=attachments[0]; //拿到一个附件MCOAttachment,可从中得到文件名，文件内容data</span><br></pre></td></tr></table></figure>
<h2 id="三、IMAP"><a href="#三、IMAP" class="headerlink" title="三、IMAP"></a>三、IMAP</h2><h3 id="1-需要先创建MCOIMAPSession，并配置连接邮箱需要的各个参数"><a href="#1-需要先创建MCOIMAPSession，并配置连接邮箱需要的各个参数" class="headerlink" title="1.需要先创建MCOIMAPSession，并配置连接邮箱需要的各个参数"></a>1.需要先创建MCOIMAPSession，并配置连接邮箱需要的各个参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">session = [[MCOIMAPSessionalloc]init];</span><br><span class="line"></span><br><span class="line">session.hostname =@&quot;imap.qq.com&quot;;</span><br><span class="line"></span><br><span class="line">session.port =993;</span><br><span class="line"></span><br><span class="line">[session setUsername:@&quot;mail@qq.com&quot;];</span><br><span class="line"></span><br><span class="line">[session setPassword:@&quot;psw&quot;];</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">[session setConnectionType:MCOConnectionTypeTLS];</span><br><span class="line"></span><br><span class="line">session.connectionLogger = ^(void * connectionID,MCOConnectionLogType type,NSData * data) &#123;</span><br><span class="line"></span><br><span class="line">        if (type != MCOConnectionLogTypeSentPrivate) &#123;</span><br><span class="line"></span><br><span class="line">            NSLog(@&quot;eventlogged:%p %i withData: %@&quot;, connectionID, type, [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">//检查登录邮箱</span><br><span class="line"></span><br><span class="line">MCOIMAPOperation *checkOp = [sessioncheckAccountOperation];</span><br><span class="line"></span><br><span class="line">    [checkOp start:^(NSError *error) &#123;</span><br><span class="line"></span><br><span class="line">         NSLog(@&quot;finished checking account.&quot;);</span><br><span class="line"></span><br><span class="line">         if (error == nil) &#123;</span><br><span class="line"></span><br><span class="line">//在这里获取邮件</span><br><span class="line"></span><br><span class="line">            [self getmail];</span><br><span class="line"></span><br><span class="line">         &#125; else &#123;</span><br><span class="line"></span><br><span class="line">             NSLog(@&quot;error loading account: %@&quot;, error);</span><br><span class="line"></span><br><span class="line">            [self hideLoading];</span><br><span class="line"></span><br><span class="line">            ALERT_SHOW(@&quot;登录邮箱失败，请检查网络重试&quot;);</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         checkOp = nil;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<h3 id="2-获取邮件"><a href="#2-获取邮件" class="headerlink" title="2.获取邮件"></a>2.获取邮件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MCOIMAPMessagesRequestKind requestKind = (MCOIMAPMessagesRequestKind)</span><br><span class="line"></span><br><span class="line">    (MCOIMAPMessagesRequestKindHeaders |MCOIMAPMessagesRequestKindStructure |</span><br><span class="line"></span><br><span class="line">     MCOIMAPMessagesRequestKindInternalDate |MCOIMAPMessagesRequestKindHeaderSubject |</span><br><span class="line"></span><br><span class="line">     MCOIMAPMessagesRequestKindFlags);</span><br><span class="line"></span><br><span class="line">MCOIndexSet *uids = [MCOIndexSetindexSetWithRange:MCORangeMake(1,UINT64_MAX)];</span><br><span class="line"></span><br><span class="line">MCOIMAPFetchMessagesOperation *fetchOperation = [sessionfetchMessagesByUIDOperationWithFolder:@&quot;INBOX&quot;requestKind:requestKinduids:uids];</span><br><span class="line"></span><br><span class="line">    //异步请求邮件，fetchedMessages为邮件列表，里面存放MCOIMAPMessage对象</span><br><span class="line"></span><br><span class="line">[fetchOperationstart:^(NSError * error,NSArray * fetchedMessages,MCOIndexSet * vanishedMessages) &#123;</span><br><span class="line"></span><br><span class="line">        if(error) &#123;</span><br><span class="line"></span><br><span class="line">            NSLog(@&quot;获取邮件列表失败。Error downloading message headers:%@&quot;, error);</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line"></span><br><span class="line">            // 在这里操作邮件内容，见3          </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="3-操作邮件内容"><a href="#3-操作邮件内容" class="headerlink" title="3.操作邮件内容"></a>3.操作邮件内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//拿出一个邮件MCOIMAPMessage(里面包含邮件头等信息)</span><br><span class="line"></span><br><span class="line">MCOIMAPMessage *message = fetchedMessages [0];</span><br><span class="line"></span><br><span class="line">//使用MCOIMAPMessageRenderingOperation来获得邮件概要信息</span><br><span class="line"></span><br><span class="line">NSString *uidKey = [NSStringstringWithFormat:@&quot;%d&quot;, message.uid];</span><br><span class="line"></span><br><span class="line">MCOIMAPMessageRenderingOperation *  messageRenderingOperation = [sessionplainTextBodyRenderingOperationWithMessage:messagefolder:@&quot;INBOX&quot;];</span><br><span class="line"></span><br><span class="line">        [messageRenderingOperationstart:^(NSString * plainTextBodyString,NSError * error) &#123;</span><br><span class="line"></span><br><span class="line">            // plainTextBodyString为邮件的正文文本信息</span><br><span class="line"></span><br><span class="line">        &#125;];</span><br></pre></td></tr></table></figure>
<h3 id="4-取到邮件内容，最终取得该邮件的MCOMessageParser"><a href="#4-取到邮件内容，最终取得该邮件的MCOMessageParser" class="headerlink" title="4.取到邮件内容，最终取得该邮件的MCOMessageParser"></a>4.取到邮件内容，最终取得该邮件的MCOMessageParser</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MCOIMAPFetchContentOperation * op = [sessionfetchMessageOperationWithFolder: @&quot;INBOX&quot;uid:[messageuid]];</span><br><span class="line">        //    [_opsaddObject:op];</span><br><span class="line"></span><br><span class="line">        [op start:^(NSError * error,NSData * data) &#123;</span><br><span class="line"></span><br><span class="line">            if ([error code] != MCOErrorNone) &#123;</span><br><span class="line"></span><br><span class="line">                ALERT_SHOW(@&quot;获取邮件数据失败&quot;);</span><br><span class="line"></span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            NSAssert(data != nil, @&quot;data != nil&quot;);</span><br><span class="line"></span><br><span class="line">            //拿到MCOMessageParser后，如何处理，跟上文pop提到的MCOMessageParser一致</span><br><span class="line"></span><br><span class="line">            MCOMessageParser * msgPaser = [MCOMessageParsermessageParserWithData:data];</span><br><span class="line"></span><br><span class="line">        &#125;];</span><br></pre></td></tr></table></figure>
<h2 id="四、SMTP"><a href="#四、SMTP" class="headerlink" title="四、SMTP"></a>四、SMTP</h2><h3 id="1-先创建MCOSMTPSession-配置好各个连接smtp邮箱的参数"><a href="#1-先创建MCOSMTPSession-配置好各个连接smtp邮箱的参数" class="headerlink" title="1.先创建MCOSMTPSession,配置好各个连接smtp邮箱的参数"></a>1.先创建MCOSMTPSession,配置好各个连接smtp邮箱的参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MCOSMTPSession*smtpSession = [[[MCOSMTPSessionalloc]init]autorelease];</span><br><span class="line"></span><br><span class="line">smtpSession.username = @&quot;yoursmtp@qq.com&quot;;</span><br><span class="line"></span><br><span class="line">smtpSession.password = @&quot;yourpws&quot;;</span><br><span class="line"></span><br><span class="line">smtpSession.hostname = @&quot;smtp.qq.com&quot;;</span><br><span class="line"></span><br><span class="line">smtpSession.port = 465;</span><br><span class="line"></span><br><span class="line">smtpSession.connectionType = MCOConnectionTypeTLS;</span><br></pre></td></tr></table></figure>
<h3 id="2-使用MCOMessageBuilder构建邮件体的发送内容"><a href="#2-使用MCOMessageBuilder构建邮件体的发送内容" class="headerlink" title="2.使用MCOMessageBuilder构建邮件体的发送内容"></a>2.使用MCOMessageBuilder构建邮件体的发送内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">MCOMessageBuilder * builder = [[[MCOMessageBuilderalloc]init]autorelease];</span><br><span class="line"></span><br><span class="line">//构建邮件头</span><br><span class="line"></span><br><span class="line">   [[builder header] setFrom:[MCOAddress addressWithDisplayName:nil mailbox: @&quot;yoursmtp@qq.com&quot;]];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//设置邮件的接受人(可以多个)</span><br><span class="line"></span><br><span class="line">NSMutableArray *to = [NSMutableArrayarray];</span><br><span class="line"></span><br><span class="line">    NSArray *recipients=[@&quot;32232@qq.com;toyou@qq.com&quot;componentsSeparatedByString:@&quot;;&quot;];</span><br><span class="line"></span><br><span class="line">for(NSString *toAddressin recipients) &#123;</span><br><span class="line"></span><br><span class="line">//使用MCOAddress封装邮箱地址</span><br><span class="line"></span><br><span class="line">        MCOAddress *newAddress = [MCOAddressaddressWithMailbox:toAddress];</span><br><span class="line"></span><br><span class="line">[to addObject:newAddress];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [[builder header] setTo:to];</span><br><span class="line"></span><br><span class="line">//设置抄送人(多个)</span><br><span class="line"></span><br><span class="line">NSArray *CC=[@&quot;cc32232@qq.com;cctoyou@qq.com&quot;componentsSeparatedByString:@&quot;;&quot;];</span><br><span class="line"></span><br><span class="line">        NSMutableArray *cc = [NSMutableArrayarray];</span><br><span class="line"></span><br><span class="line">        for(NSString *ccAddressin CC) &#123;</span><br><span class="line"></span><br><span class="line">            MCOAddress *newAddress = [MCOAddressaddressWithMailbox:ccAddress];</span><br><span class="line"></span><br><span class="line">                [ccaddObject:newAddress];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       [[builder header] setCc:cc];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//设置密送人（多个）</span><br><span class="line"></span><br><span class="line">           NSArray *BCC=[@&quot;bc32232@qq.com;bctoyou@qq.com&quot;componentsSeparatedByString:@&quot;;&quot;];</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        NSMutableArray *bcc = [NSMutableArrayarray];</span><br><span class="line"></span><br><span class="line">        for(NSString *bccAddressin BCC) &#123;</span><br><span class="line"></span><br><span class="line">            MCOAddress *newAddress = [MCOAddressaddressWithMailbox:bccAddress];</span><br><span class="line"></span><br><span class="line">               [bcc addObject:newAddress];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [[builder header] setBcc:bcc];</span><br><span class="line"></span><br><span class="line">//设置邮件标题</span><br><span class="line"></span><br><span class="line">[[builder header] setSubject: @&quot;给你的邮件&quot;];</span><br><span class="line"></span><br><span class="line">//设置邮件正文（纯文本）</span><br><span class="line"></span><br><span class="line">[builder setTextBody: @&quot;测试邮件的正文部分&quot;];</span><br><span class="line"></span><br><span class="line">ps:如果邮件是回复或者转发，原邮件中往往有附件以及正文中有其他图片资源，如果有需要你可将原文原封不动的也带过去，这里发送的正文就可以如下配置：</span><br><span class="line"></span><br><span class="line">NSString * bodyHtml=@”&lt;p&gt;我是原邮件正文&lt;/p&gt;”;</span><br><span class="line"></span><br><span class="line">NSString *body=@&quot;我是邮件回复的内容&quot;;</span><br><span class="line"></span><br><span class="line">NSMutableString*fullBodyHtml=[NSMutableStringstringWithFormat:@&quot;%@&lt;br/&gt;-------------原始邮件-------------&lt;br/&gt;%@&quot;,[body stringByReplacingOccurrencesOfString:@&quot;\n&quot;withString:@&quot;&lt;br/&gt;&quot;],bodyHtml];</span><br><span class="line"></span><br><span class="line"> [builder setHTMLBody:fullBodyHtml];</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">//添加正文里的附加资源</span><br><span class="line"></span><br><span class="line">NSArray *inattachments=msgPaser.htmlInlineAttachments;</span><br><span class="line"></span><br><span class="line">        for (MCOAttachment*attachmentininattachments) &#123;</span><br><span class="line"></span><br><span class="line">           [builder addRelatedAttachment:attachment];//添加html正文里的附加资源（图片）</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">//添加邮件附件</span><br><span class="line"></span><br><span class="line">for (MCOAttachment*attachmentinattachments) &#123;</span><br><span class="line"></span><br><span class="line">           [builder addAttachment:attachment];//添加附件</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-将构建好的邮件体发送出去"><a href="#3-将构建好的邮件体发送出去" class="headerlink" title="3.将构建好的邮件体发送出去"></a>3.将构建好的邮件体发送出去</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NSData * rfc822Data =[builder data];</span><br><span class="line"></span><br><span class="line">MCOSMTPSendOperation *sendOperation = [smtpSessionsendOperationWithData:rfc822Data];</span><br><span class="line"></span><br><span class="line">[sendOperation start:^(NSError *error) &#123;</span><br><span class="line"></span><br><span class="line">        if(error) &#123;</span><br><span class="line"></span><br><span class="line">            NSLog(@&quot;%@邮件发送失败Error sending email:%@&quot;, username, error);</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            NSLog(@&quot;%@ Successfullysent email!&quot;, username);</span><br><span class="line"></span><br><span class="line">            UIAlertView *alert=[[UIAlertViewalloc]initWithTitle:@&quot;温馨提示&quot;message:@&quot;发送成功&quot;delegate:selfcancelButtonTitle:@&quot;确认&quot;otherButtonTitles:nil];</span><br><span class="line"></span><br><span class="line">            [alert show];</span><br><span class="line"></span><br><span class="line">            [alert release];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/22/Mailcore2源码阅读/" data-id="cjtjd6py4002ln8oc0sw5b6j7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/网安组/">网安组</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络安全/">网络安全</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/网络安全/" style="font-size: 10px;">网络安全</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/22/第二章逆向分析HelloWord程序/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/03/22/Chapter2VariablesandFundamentalDataTypes/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/03/22/Chapter1CBasics/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/03/22/第三章数据类型与运算符/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/03/22/第二章理解结构化程序设计/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 闳<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>