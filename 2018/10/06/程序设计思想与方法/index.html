
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>程序设计思想与方法 | 闳</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="柳柳">
    

    
    <meta name="description" content="第一章 计算与计算思维一、计算机语言1.高级语言的翻译有两种方式：编译和解释； 2.编译器（compiler）将高级语言程序（称为源代码）完整地翻译成等价的机器语言程序（称为目标代码）；">
<meta name="keywords" content="微机原理">
<meta property="og:type" content="article">
<meta property="og:title" content="程序设计思想与方法">
<meta property="og:url" content="http://yoursite.com/2018/10/06/程序设计思想与方法/index.html">
<meta property="og:site_name" content="闳">
<meta property="og:description" content="第一章 计算与计算思维一、计算机语言1.高级语言的翻译有两种方式：编译和解释； 2.编译器（compiler）将高级语言程序（称为源代码）完整地翻译成等价的机器语言程序（称为目标代码）；">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://wizardforcel.gitbooks.io/sjtu-cs902-courseware/content/img/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%9579929.png">
<meta property="og:image" content="https://wizardforcel.gitbooks.io/sjtu-cs902-courseware/content/img/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95200997.png">
<meta property="og:image" content="https://wizardforcel.gitbooks.io/sjtu-cs902-courseware/content/img/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95204066.png">
<meta property="og:image" content="https://wizardforcel.gitbooks.io/sjtu-cs902-courseware/content/img/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95206135.png">
<meta property="og:image" content="https://wizardforcel.gitbooks.io/sjtu-cs902-courseware/content/img/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95227730.png">
<meta property="og:updated_time" content="2019-03-26T06:55:27.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序设计思想与方法">
<meta name="twitter:description" content="第一章 计算与计算思维一、计算机语言1.高级语言的翻译有两种方式：编译和解释； 2.编译器（compiler）将高级语言程序（称为源代码）完整地翻译成等价的机器语言程序（称为目标代码）；">
<meta name="twitter:image" content="https://wizardforcel.gitbooks.io/sjtu-cs902-courseware/content/img/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%9579929.png">

    
    <link rel="alternative" href="/atom.xml" title="闳" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="闳" title="闳"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="闳">闳</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/10/06/程序设计思想与方法/" title="程序设计思想与方法" itemprop="url">程序设计思想与方法</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="柳柳" target="_blank" itemprop="author">柳柳</a>
		
  <p class="article-time">
    <time datetime="2018-10-06T08:07:40.000Z" itemprop="datePublished"> Published 2018-10-06</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#第一章-计算与计算思维"><span class="toc-number">1.</span> <span class="toc-text">第一章 计算与计算思维</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、计算机语言"><span class="toc-number">1.1.</span> <span class="toc-text">一、计算机语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、算法"><span class="toc-number">1.2.</span> <span class="toc-text">二、算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、计算思维的的基本原则"><span class="toc-number">1.3.</span> <span class="toc-text">三、计算思维的的基本原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第三章-数据处理的流程控制"><span class="toc-number">2.</span> <span class="toc-text">第三章 数据处理的流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、循序控制结构"><span class="toc-number">2.1.</span> <span class="toc-text">一、循序控制结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、异常处理"><span class="toc-number">2.2.</span> <span class="toc-text">二、异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、结构化程序设计"><span class="toc-number">2.3.</span> <span class="toc-text">三、结构化程序设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第四章-模块化编程"><span class="toc-number">3.</span> <span class="toc-text">第四章 模块化编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、模块化编程基本概念"><span class="toc-number">3.1.</span> <span class="toc-text">一、模块化编程基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、自顶向下设计"><span class="toc-number">3.2.</span> <span class="toc-text">二、自顶向下设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、自底向上实现与单元测试"><span class="toc-number">3.3.</span> <span class="toc-text">三、自底向上实现与单元测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第六章-大量数据的表示和处理"><span class="toc-number">4.</span> <span class="toc-text">第六章 大量数据的表示和处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、简单数据和复杂数据"><span class="toc-number">4.1.</span> <span class="toc-text">一、简单数据和复杂数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、几种高级数据结构"><span class="toc-number">4.2.</span> <span class="toc-text">二、几种高级数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第七章-面向对象思想与编程"><span class="toc-number">5.</span> <span class="toc-text">第七章 面向对象思想与编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、数据与操作：两种观点"><span class="toc-number">5.1.</span> <span class="toc-text">一、数据与操作：两种观点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、面向过程的观点"><span class="toc-number">5.1.1.</span> <span class="toc-text">1、面向过程的观点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、面向对象观点"><span class="toc-number">5.1.2.</span> <span class="toc-text">2、面向对象观点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-类是类型概念的发展"><span class="toc-number">5.1.3.</span> <span class="toc-text">3.类是类型概念的发展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、面向对象的编程"><span class="toc-number">5.2.</span> <span class="toc-text">二、面向对象的编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-类的定义"><span class="toc-number">5.2.1.</span> <span class="toc-text">1.类的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-对象的创建"><span class="toc-number">5.2.2.</span> <span class="toc-text">2.对象的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-对象的调用"><span class="toc-number">5.2.3.</span> <span class="toc-text">3.对象的调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-类与模块化"><span class="toc-number">5.2.4.</span> <span class="toc-text">4.类与模块化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-对象的集合体"><span class="toc-number">5.2.5.</span> <span class="toc-text">5.对象的集合体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、超类与子类"><span class="toc-number">5.3.</span> <span class="toc-text">三、超类与子类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-继承"><span class="toc-number">5.3.1.</span> <span class="toc-text">1.继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-复写"><span class="toc-number">5.3.2.</span> <span class="toc-text">2.复写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-多态性"><span class="toc-number">5.3.3.</span> <span class="toc-text">3.多态性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、面向对象的设计"><span class="toc-number">5.4.</span> <span class="toc-text">四、面向对象的设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第八章-图形用户界面"><span class="toc-number">6.</span> <span class="toc-text">第八章 图形用户界面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、图形用户界面概述"><span class="toc-number">6.1.</span> <span class="toc-text">一、图形用户界面概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、GUI编程"><span class="toc-number">6.2.</span> <span class="toc-text">二、GUI编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GUI-编程一般需要如下几个步骤："><span class="toc-number">6.2.1.</span> <span class="toc-text">GUI 编程一般需要如下几个步骤：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#框架"><span class="toc-number">6.2.2.</span> <span class="toc-text">框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#布局"><span class="toc-number">6.2.3.</span> <span class="toc-text">布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对话框"><span class="toc-number">6.2.4.</span> <span class="toc-text">对话框</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事件处理"><span class="toc-number">6.2.5.</span> <span class="toc-text">事件处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#键盘事件与焦点"><span class="toc-number">6.2.6.</span> <span class="toc-text">键盘事件与焦点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、模型-视图设计方法"><span class="toc-number">6.3.</span> <span class="toc-text">三、模型-视图设计方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-将-GUI-应用程序封装成对象"><span class="toc-number">6.3.1.</span> <span class="toc-text">1.将 GUI 应用程序封装成对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-模型与视图"><span class="toc-number">6.3.2.</span> <span class="toc-text">2.模型与视图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第九章-模拟开发与并发"><span class="toc-number">7.</span> <span class="toc-text">第九章 模拟开发与并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、模拟"><span class="toc-number">7.1.</span> <span class="toc-text">一、模拟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、原型法"><span class="toc-number">7.2.</span> <span class="toc-text">二、原型法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、并行计算"><span class="toc-number">7.3.</span> <span class="toc-text">三、并行计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-串行、并发与并行"><span class="toc-number">7.3.1.</span> <span class="toc-text">1.串行、并发与并行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-进程与线程"><span class="toc-number">7.3.2.</span> <span class="toc-text">2.进程与线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-多线程编程的应用"><span class="toc-number">7.3.3.</span> <span class="toc-text">3.多线程编程的应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第十章-算法设计和分析"><span class="toc-number">8.</span> <span class="toc-text">第十章 算法设计和分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、枚举法"><span class="toc-number">8.1.</span> <span class="toc-text">一、枚举法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、递归"><span class="toc-number">8.2.</span> <span class="toc-text">二、递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、分治法"><span class="toc-number">8.3.</span> <span class="toc-text">三、分治法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、贪心法"><span class="toc-number">8.4.</span> <span class="toc-text">四、贪心法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五、算法分析"><span class="toc-number">8.5.</span> <span class="toc-text">五、算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-算法复杂度"><span class="toc-number">8.5.1.</span> <span class="toc-text">1.算法复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-算法分析实例"><span class="toc-number">8.5.2.</span> <span class="toc-text">2.算法分析实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#六、不可计算问题"><span class="toc-number">8.5.3.</span> <span class="toc-text">六、不可计算问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第11章-计算-X"><span class="toc-number">9.</span> <span class="toc-text">第11章 计算+X</span></a></li></ol>
		
		</div>
		
		<h2 id="第一章-计算与计算思维"><a href="#第一章-计算与计算思维" class="headerlink" title="第一章 计算与计算思维"></a>第一章 计算与计算思维</h2><h3 id="一、计算机语言"><a href="#一、计算机语言" class="headerlink" title="一、计算机语言"></a>一、计算机语言</h3><p>1.高级语言的翻译有两种方式：编译和解释；</p>
<p>2.编译器（compiler）将高级语言程序（称为源代码）完整地翻译成等价的机器语言程序（称为目标代码）；<br><a id="more"></a></p>
<h3 id="二、算法"><a href="#二、算法" class="headerlink" title="二、算法"></a>二、算法</h3><p>1.解决特定问题的、由一系列明确而可行的步骤 组成的过程，称为算法（algorithm①）；</p>
<p>2.算法有两个要求：第一，每个步骤必须具备明确的可操作性；第二，构成算法的 所有步骤必须能在有限时间内完成。</p>
<p>3.计算机科学要<br>回答的一个基本问题：什么是可计算的？如果能够为某个问题找到算法，该问题就称为可计 算的。</p>
<h3 id="三、计算思维的的基本原则"><a href="#三、计算思维的的基本原则" class="headerlink" title="三、计算思维的的基本原则"></a>三、计算思维的的基本原则</h3><p>1.正如数学家在证明数学定理时有独特的数学思维、工程师在设计制造产品时 有独特的工程思维、艺术家在创作诗歌音乐绘画时有独特的艺术思维一样，计算机科学家在 用计算机解决问题时也有自己独特的思维方式和解决方法，我们统称之为 计算思维；</p>
<p>2.“电子电路®门逻辑® 二进制®机器语言指令®高级语言程序”；</p>
<h2 id="第三章-数据处理的流程控制"><a href="#第三章-数据处理的流程控制" class="headerlink" title="第三章 数据处理的流程控制"></a>第三章 数据处理的流程控制</h2><h3 id="一、循序控制结构"><a href="#一、循序控制结构" class="headerlink" title="一、循序控制结构"></a>一、循序控制结构</h3><p>1.由于复杂问 题的解法可能涉及复杂的执行次序，因此编程语言必须提供表达复杂控制流程的手段，称为 编程语言的控制结构。                                         </p>
<h3 id="二、异常处理"><a href="#二、异常处理" class="headerlink" title="二、异常处理"></a>二、异常处理</h3><p>1.具体的检测方式有两种， 一种是在执行任务之前检测条件，另一种是执行任务之后检测返回状态码或错误码。</p>
<p>2.异常处理机制</p>
<p>异常处理机制的基本思想是：程序运行 时如果发生错误，就“抛出”一个异常，而系统能够“捕获”这个异常并执行特定的异常处 理代码。</p>
<p><img src="https://wizardforcel.gitbooks.io/sjtu-cs902-courseware/content/img/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%9579929.png" alt=""></p>
<h3 id="三、结构化程序设计"><a href="#三、结构化程序设计" class="headerlink" title="三、结构化程序设计"></a>三、结构化程序设计</h3><p>1.开发新系统阶段的任务大体上就是程序设计，它本身又可划分为几个步骤，构成程序开 发周期（PDC）。PDC 的各个步骤如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.明确需求：明确问题是什么，理解用户在功能方面的要求。</span><br><span class="line"></span><br><span class="line">2.制定程序规格：描述程序要“做什么”。</span><br><span class="line"></span><br><span class="line">3.设计程序逻辑：设计程序的解题过程，即描述“怎么做”。</span><br><span class="line"></span><br><span class="line">4.实现：使用一种编程语言来实现设计，即编写程序代码。</span><br><span class="line"></span><br><span class="line">5.测试与排错：用样本数据执行程序，测试结果是否与预期吻合。如果发现有错误（行 话称为 bug）则排除错误（debug）。</span><br><span class="line"></span><br><span class="line">6.维护程序：根据用户需求持续开发、改进程序。 程序规格描述程序的要做什么事情，对于简单程序通常只需要描述程序的输入和输出分别是什么。</span><br></pre></td></tr></table></figure></p>
<p>2.好的算法和程序就像逻辑的诗歌。读和维护 都很愉快。</p>
<h2 id="第四章-模块化编程"><a href="#第四章-模块化编程" class="headerlink" title="第四章 模块化编程"></a>第四章 模块化编程</h2><h3 id="一、模块化编程基本概念"><a href="#一、模块化编程基本概念" class="headerlink" title="一、模块化编程基本概念"></a>一、模块化编程基本概念</h3><p>1.模块一般具有如下特征：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">标准化：模块是具有标准尺寸和标准接口的预制功能单元，这是组装、互换等特征 的基础。</span><br><span class="line"></span><br><span class="line">可组装：多个模块可以方便、灵活地组合、配置，以构造不同大小、不同形状、不 同功能的系统。</span><br><span class="line"></span><br><span class="line">可替换：通过用一个模块去更换另一个模块，可以改变系统的局部功能而不影响系 统的其他部分。</span><br><span class="line"></span><br><span class="line">可维护：可以对模块进行局部修改或设置，以满足用户的需求。另外可以在现有系 统中增加新模块，以扩展系统功能。</span><br></pre></td></tr></table></figure>
<h3 id="二、自顶向下设计"><a href="#二、自顶向下设计" class="headerlink" title="二、自顶向下设计"></a>二、自顶向下设计</h3><ol>
<li>自顶向下设计也称为逐步求精（stepwise refinement），是将一个系统逐层分解为子系统的设计过程。</li>
<li>用自顶向下方法编程序时，总是先写主程序，它是由根据系统功能划分而 成的功能子程序组成的。然后再分析每个子程序的需求，如果有必要就继续像主程序一样分 解下去。</li>
</ol>
<h3 id="三、自底向上实现与单元测试"><a href="#三、自底向上实现与单元测试" class="headerlink" title="三、自底向上实现与单元测试"></a>三、自底向上实现与单元测试</h3><p>1.自顶向下设计设计是创建层次化的模块结构的过程，而从实现的角度看，我们又是采取了相反的过程，即自底向上的实现。</p>
<p>2.在模块化编程中，测试程序最适合采用单元测试技术，即先分别测试每一个小模块，然 后再逐步测试较大的模块，直至最后测试完整程序。</p>
<p>3.典型的层次化软件体系结构的例子包括数据库的 ANSI-SPARC 三层模式、 网络技术的 ISO/OSI 七层模型、Web 应用开发中的三层体系结构等等。</p>
<p>4.层次化体系结构的主要缺点是效率不如整体式结构，这是因为当程序员或用户面对顶层 构件请求某项服务时，这个请求需要从高层到低层逐层下传，最终由底层构件来实现功能， 再将结果逐层上传，直至顶层用户。这个逐层转换的过程显然很耗费时间。</p>
<h2 id="第六章-大量数据的表示和处理"><a href="#第六章-大量数据的表示和处理" class="headerlink" title="第六章 大量数据的表示和处理"></a>第六章 大量数据的表示和处理</h2><h3 id="一、简单数据和复杂数据"><a href="#一、简单数据和复杂数据" class="headerlink" title="一、简单数据和复杂数据"></a>一、简单数据和复杂数据</h3><p>1.简单数据一般指单个数据，并且没有内部结构， 不可分割。复杂数据正相反，可在两方面呈现复杂性：一是数量多，即待处理的数据是由大 量相互关联的成员数据组成的；二是有内部结构，即数据在内部由若干分量组成，每个分量 本身可能又由更小的分量组成。</p>
<h3 id="二、几种高级数据结构"><a href="#二、几种高级数据结构" class="headerlink" title="二、几种高级数据结构"></a>二、几种高级数据结构</h3><p>1.链表：列表是由许多数据按次序排列形成的一种数据结构，列表成员之间的逻辑关 系是由他们的排列次序表示的。</p>
<p>但连续存储结构有也有缺点：如 果需要增加新成员，必须移动大量数据以便为新成员腾出空间；如果要删除某个数据，删除 后必须移动大量数据以便填补空缺、保持连续性。</p>
<p><img src="https://wizardforcel.gitbooks.io/sjtu-cs902-courseware/content/img/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95200997.png" alt=""></p>
<p>2.堆栈：堆栈（stack）也是一种数据集合体，其中的数据构成一种具有“后进先出（LIFO）”性 质的数据结构，即最后加入堆栈的数据总是首先取出。<br><img src="https://wizardforcel.gitbooks.io/sjtu-cs902-courseware/content/img/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95204066.png" alt=""></p>
<p>3.队列队列（queue）也是数据集合体，其中的数据成员有序排列。与堆栈的“后进先出”相 反，队列具有“先进先出（FIFO）”的性质，即最先加入队列的数据将最先移出队列。<br><img src="https://wizardforcel.gitbooks.io/sjtu-cs902-courseware/content/img/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95206135.png" alt=""></p>
<h2 id="第七章-面向对象思想与编程"><a href="#第七章-面向对象思想与编程" class="headerlink" title="第七章 面向对象思想与编程"></a>第七章 面向对象思想与编程</h2><p>面向对象思想和方法具有强大的描述复杂数据和构建复杂系统的能力，因此面向对象编 程已成为当今流行的编程范型，是大多数程序员在解决问题时的不二之选。</p>
<h3 id="一、数据与操作：两种观点"><a href="#一、数据与操作：两种观点" class="headerlink" title="一、数据与操作：两种观点"></a>一、数据与操作：两种观点</h3><p>1.关于数据和操作这两部分的关系，在程序设计思想和方法的发展过程中存在两种不同的 观点：一种是传统的以操作为中心的面向过程观点，一种是现代的以数据为中心的面向对象 观点。</p>
<h4 id="1、面向过程的观点"><a href="#1、面向过程的观点" class="headerlink" title="1、面向过程的观点"></a>1、面向过程的观点</h4><p>1.在数据与操作分离的传统观点下，通常以算法过程的设计为主线来展开程序设计，故可称为以过程为中心的程序设计。</p>
<p>2.复杂程序中不但数据复杂，而且对数 据的操作也非常复杂，所有操作可能形成漫长而曲折的过程。为了应付操作过程的复杂性， 按照第 4 章所介绍的模块化编程思想，可以将复杂操作过程组织成为若干个较小的模块—— 函数，每个函数实现一个相对简单的、单一的功能。</p>
<p>3.为了适应 GUI 程序这类没有明确的预定义操作次序、靠不确定的事件来驱动的程序和系 统的开发，提高开发效率和质量，计算机科学家提出了一种新的观点来看待数据与操作之间 的关系，即面向对象的观点。</p>
<h4 id="2、面向对象观点"><a href="#2、面向对象观点" class="headerlink" title="2、面向对象观点"></a>2、面向对象观点</h4><p>1.数据与对数据的操作确实是紧密相关、不可分离的。既然如此，那我们干脆将数 据和操作两者结合在一起，抽象出一种实体：该实体拥有一些数据，同时也知道如何对这些 数据进行操作。</p>
<p>2.我们将数据和对数据的操作融为一体，形成具有静态信息和动态行为的对象。 以面向对象的观点去描述现实世界，就是要将现实世界刻画成由各种对象组成，并且各对象之间进行交互、协作的系统。</p>
<h4 id="3-类是类型概念的发展"><a href="#3-类是类型概念的发展" class="headerlink" title="3.类是类型概念的发展"></a>3.类是类型概念的发展</h4><p>1.类（class）是广义的数据类型，能够定义复杂数据的特性，包括静态特性（即数据）和动态特性（即对数据的操作方法）。</p>
<h3 id="二、面向对象的编程"><a href="#二、面向对象的编程" class="headerlink" title="二、面向对象的编程"></a>二、面向对象的编程</h3><h4 id="1-类的定义"><a href="#1-类的定义" class="headerlink" title="1.类的定义"></a>1.类的定义</h4><p>1.抽象：人们在认识客观世界时，经常采用抽象方法来对客观世界的众多事物进行归纳、分类。 抽象就是忽略事物中与当前目标无关的、非本质的特征，而抽取与当前目标有关的、本质的特征。</p>
<p>例如，对学校里一个个具体的学生张三、李四、王五等进行概括，可以抽取出学号、姓 名等数据属性，还可以抽取出选课、做项目、加入学生社团等行为属性，从而建立“学生类”。</p>
<p>2.封装：封装（encapsulation）是指用类将对象的数据和操作结合成一个封闭的程序单元，并对 外部隐藏内部实现细节。</p>
<p>隐藏信息包含两重意思：一是用户无需了解隐藏的信息就能使用该 类，二是不允许用户直接操作类中被隐藏的信息。</p>
<p>3.事实上，类可以看作是传统结构 类型的发展，即类是添加了数据操作的“结构”。</p>
<h4 id="2-对象的创建"><a href="#2-对象的创建" class="headerlink" title="2.对象的创建"></a>2.对象的创建</h4><p>1.一旦定义了类，就可以创建类的实例，也就是该类的一个对象②。类是抽象的，而对象<br>则是具体的。</p>
<p>2.这里将类名当成一个函数来用，称为类的构造器（constructor，或称构造函数）。构造器返回 一个新对象，通常需要定义&lt;变量&gt;来引用这个新对象。</p>
<h4 id="3-对象的调用"><a href="#3-对象的调用" class="headerlink" title="3.对象的调用"></a>3.对象的调用</h4><ol>
<li>一旦创建了对象，就可以通过向对象发消息来调用对象的方法。消息的格式如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;对象&gt;.&lt;方法&gt;(&lt;实参&gt;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="4-类与模块化"><a href="#4-类与模块化" class="headerlink" title="4.类与模块化"></a>4.类与模块化</h4><p>1.对复杂程序一般有两种分解方法：功能分解和数据分解。功能分解是面向过程编程的基 础，依赖于子程序（如函数）概念，以过程为中心来建立功能模块；数据分解则是面向对象 编程的基础，依赖于类的概念，以数据为中心来建立数据模块。</p>
<p>2.当然可以让每个类单独构成一个模块，但这样一来，当类的数目很多时会导致模块 数目过多，反而增加程序的复杂性。</p>
<h4 id="5-对象的集合体"><a href="#5-对象的集合体" class="headerlink" title="5.对象的集合体"></a>5.对象的集合体</h4><p>1.用 集合体表示大量的数据成员，而每个数据成员是一个具有复杂内部结构的对象。我们不妨用 下面的公式来表达这个思想：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类 + 集合体 ＝ 任意复杂的数据</span><br></pre></td></tr></table></figure></p>
<h3 id="三、超类与子类"><a href="#三、超类与子类" class="headerlink" title="三、超类与子类"></a>三、超类与子类</h3><p><img src="https://wizardforcel.gitbooks.io/sjtu-cs902-courseware/content/img/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95227730.png" alt=""></p>
<p>为了描述这种一般与特殊的关系，面向对象语言中提供了相应的类定义方式。具有一般性的类称为超类（superclass），具有特殊性的类称为子类（subclass）①。例如在图 7.11 中， “人”是“学生”的超类，“学生”是“人”的子类；“人”也是“教师”的超类，“教师”是 “人”的子类；“学生”又是“研究生”的超类，“研究生”是“学生”的子类；等等。</p>
<h4 id="1-继承"><a href="#1-继承" class="headerlink" title="1.继承"></a>1.继承</h4><p>1.子类拥有超类的一切特性，凡是超类适用的地方，子类也适用。</p>
<p>2.子类除了继承超类的属性，还包含一些自己的特殊属性。</p>
<p>3.这种定义方式下，子类中不必重复定义那些继承 来的属性，从而简化了子类定义。这也是继承机制带来了的另一个重要特色——代码重用（code reuse），即超类中的代码可以通过继承机制被子类重复使用。</p>
<h4 id="2-复写"><a href="#2-复写" class="headerlink" title="2.复写"></a>2.复写</h4><p>1.子类除了原样继承超类的方法，还可以修改继承来的超类方法，以便以自己的方式行事。 这种在子类中重新定义超类方法的情况是面向对象的又一特色，称为覆写（override，或称重 定义）。</p>
<p>2.注意，覆写是指在子类中重新实现超类的方法，该方法的调用界面（参数和返回值）是 不能改变的。另外，子类中覆写的方法仅适用于子类对象，并不能取代超类中的对应方法。</p>
<h4 id="3-多态性"><a href="#3-多态性" class="headerlink" title="3.多态性"></a>3.多态性</h4><p>1.在 OOP 中，多个不同类的对象都支持相同的消息，但各对象响应消息的行为不同，这种能 力称为多态性（polymorphism），即同一操作具有不同形态的意思。</p>
<p>2.多态性使得我们能够刻划不同类所提供的相似方法，对使用者来说易理解、易使用，能 够减少编程错误。相反，不同类的相似方法如果定义为不同名字，对使用者来说就很不方便。 例如，在 Windows 环境下，“双击”就是一个多态操作，双击不同对象导致的行为是不同的。 双击可执行文件，能够执行程序；双击 mp3 文件，可以播放音乐；双击窗口标题栏，可以极 大化或恢复窗口大小；等等。用户如果知道“双击”大体上执行“打开”这个动作的话，那 么学习使用 Windows 时就能举一反三。</p>
<h3 id="四、面向对象的设计"><a href="#四、面向对象的设计" class="headerlink" title="四、面向对象的设计"></a>四、面向对象的设计</h3><ol>
<li>传统的程序设计方法是结构化的自顶向下设计，其思想是将软件系统分解为若干个功能，<br>每个功能都是对数据的一个操作过程。功能又可以划分为若干个子功能，如此反复分解下去， 直至每个功能所对应的操作过程显而易见为止。在分解功能的同时，还要考虑各功能之间的 接口。这种方法是以过程（函数）为中心的，每个函数都是一个黑盒子，函数调用者只需了 解函数的功能，无需知道实现功能的细节。</li>
</ol>
<p>2.面向对象设计是以数据为中心来展开的。对于某种客观实体的数据，考虑可能施加在数 据上的各种操作，然后将数据和操作封装成一个黑盒子——对象。对象通过界面向外界提供 数据操作服务，服务的使用者只需了解服务接口，不必关心服务的实现细节。</p>
<p>3.OOD 将一个复杂问题分解成一组相互协作的类，以类为设计单位可以大大减小设计的复杂性。</p>
<p>4.迭代设计：对于复杂程序设计，没有人能够一次性地顺利走过设计全过程。在设计过程中，经常需 要在设计、测试、增加新类或为现有类增加新方法等步骤之间循环往复。</p>
<h2 id="第八章-图形用户界面"><a href="#第八章-图形用户界面" class="headerlink" title="第八章 图形用户界面"></a>第八章 图形用户界面</h2><h3 id="一、图形用户界面概述"><a href="#一、图形用户界面概述" class="headerlink" title="一、图形用户界面概述"></a>一、图形用户界面概述</h3><p>1.在程序设计领域，一个程序的用户界面（user interface，简称 UI）指的是程序中与用户进行交互的部 分，用户通过 UI 向程序输入数据或者请求程序执行特定任务，而程序通过 UI 向用户显示各 种信息。</p>
<p>2.事件驱动的程序一般都有一个主循环（main loop）或称事件循环，该循环不停地做两件 事：事件监测和事件处理。首先要监测是否发生了事件，如果有事件发生则调用相应的事件 处理程序，处理完毕再继续监测新事件。</p>
<h3 id="二、GUI编程"><a href="#二、GUI编程" class="headerlink" title="二、GUI编程"></a>二、GUI编程</h3><h4 id="GUI-编程一般需要如下几个步骤："><a href="#GUI-编程一般需要如下几个步骤：" class="headerlink" title="GUI 编程一般需要如下几个步骤："></a>GUI 编程一般需要如下几个步骤：</h4><p>1.设计界面外观：这包括创建窗口和其他各种构件，并进行合适的布局。这一步与其 说是程序设计，不如说是美工设计。在流行的 Visual Basic、Eclipse 等集成开发环境 中，这一步只需用鼠标点击、拖放、调整大小就能完成。</p>
<p>2.为每个构件定义事件处理程序：这一步是 GUI 开发的核心任务，决定着程序的功能 和与用户交互时的行为。</p>
<p>3.编写应用程序的启动和总控部分：进行必要的初始化工作之后，进入主循环。 不同应用程序的用户界面虽然肯定会有不同，但构件的选择和布局是有很多共性的。读者如果用过一些 Windows 应用程序（如 MS Office 中的各种程序）的话，一定会发现众多 Windows 程序在界面风格方面的雷同。以下我们虽然用 Tkinter 来实现 GUI，但各种构件的 用法和布局的讨论是有普遍意义的。</p>
<h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>1.框架就是一种容器，其主要用途是将一组相关的基本构件组合成为一个“复合” 构件。利用框架对窗口进行模块化分隔，即可建立复杂的图形界面结构。每个框架都是一个 独立的区域，可以独立地对其中包含的子构件进</p>
<h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><p>布局指的是界面元素在界面中的位置安排。Tkinter 中提供了布局管理器，其任务是根据 程序员的要求以及其他一些约束来安排构件的位置。使用布局管理器的优点是程序员不需要 了解底层显示系统的细节，可以在较高层次上考虑界面布局问题。</p>
<h4 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h4><p>对话框分为两种类型：模态（modal）和非模态（modeless）对话框①。模态对话框在关 闭之前将阻止程序其他窗口的操作，而非模态对话框则不会阻止程序其他窗口的操作。模态 对话框常用于向用户警告重要信息，或者等待用户输入必需的数据（如登录用户名和密码、 打开或保存文件输入文件名等）。</p>
<h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h4><p>1.事件处理程序一般都是用户自定义的函数。这种函数在应用程序中定义，但不由应用程 序调用，而是由系统调用，所以一般称为回调（callback）函数。</p>
<h4 id="键盘事件与焦点"><a href="#键盘事件与焦点" class="headerlink" title="键盘事件与焦点"></a>键盘事件与焦点</h4><p>当图形界面中存在许多构件时，如果是用鼠标直接点击某个窗口或构件，程序自然就知<br>道要操作哪个构件。但如果是按一下键盘，应该由哪个构件做出响应呢？GUI 引入了“焦点” 概念：图形界面中有唯一焦点，任何时刻只能有一个构件占有焦点，键盘事件总是发送到当 前占有焦点的构件。焦点的位置可以通过构件的 focus_set()方法来设置，也可以用键盘上的 Tab 键来轮转。</p>
<h3 id="三、模型-视图设计方法"><a href="#三、模型-视图设计方法" class="headerlink" title="三、模型-视图设计方法"></a>三、模型-视图设计方法</h3><h4 id="1-将-GUI-应用程序封装成对象"><a href="#1-将-GUI-应用程序封装成对象" class="headerlink" title="1.将 GUI 应用程序封装成对象"></a>1.将 GUI 应用程序封装成对象</h4><p>1.GUI 编程的一个常用技术是将整个应用程序封装成一个类，在应用程序类中建立图形界 面并处理各种交互事件。</p>
<p>2.具体来说，GUI 应用程序类应该首先创建一个主窗口，并在其中布 置所需的各种构件，然后再为各个构件编写事件处理程序（都是类的方法）。这种做法的好处 是：由于事件处理函数都定义为应用类的方法，而类的方法很自然地能访问类中的实例变量， 所以只要我们将界面中的各种构件也存储为实例变量，就能实现程序的处理代码与程序的图 形界面进行“无缝集成”。</p>
<h4 id="2-模型与视图"><a href="#2-模型与视图" class="headerlink" title="2.模型与视图"></a>2.模型与视图</h4><p>1.复杂应用程序经常可以分解成两个部分：核心逻辑和用户界面。</p>
<p>2.程序的核心逻辑部分称<br>为模型（model），它负责为应用问题建模，管理应用问题的数据和行为，并对来自用户界面 的数据请求或数据更新指令进行响应。</p>
<p>3.程序的用户界面部分称为视图（view），它负责显示模 型的当前数据状态，响应用户的交互动作。模型和视图是相互独立的，可以分开设计和测试， 从而简化程序结构、降低设计难度，这称为模型－视图（MV）设计方法。</p>
<h2 id="第九章-模拟开发与并发"><a href="#第九章-模拟开发与并发" class="headerlink" title="第九章 模拟开发与并发"></a>第九章 模拟开发与并发</h2><h3 id="一、模拟"><a href="#一、模拟" class="headerlink" title="一、模拟"></a>一、模拟</h3><p>1.利用计算机解决现实中的问题，首先需要在计算机中将问题表示出来，这个过程称为建模（modeling），即建立描述现实问题的一个模型（model）。</p>
<p>2.谓混沌现象， 是指在确定性系统中发生的看上去随机、不规则的运动，即用确定性理论描述的系统却表现 出不确定的行为。</p>
<h3 id="二、原型法"><a href="#二、原型法" class="headerlink" title="二、原型法"></a>二、原型法</h3><p>1.自顶向下设计是非常强大的程 序设计技术，但它也有不适用的场合。</p>
<p>2.自顶向下设计的第一步是顶层设计，这需要设计者对问题的全局有清晰的认识。万一要 解决的问题非常复杂，或者用户需求不是很完整、清晰，这时顶层设计就非常困难。另外， 设计者有时候会卡在自顶向下层次中的某一层，这就导致下层的精化无法继续，从而影响整 个程序的开发。即便前面这两个问题都不存在，自顶向下设计也存在开发周期过长、工作量 太大的缺点。</p>
<p>3.原型法（prototyping）。这种方法的思想是，先开发一个简单版 本，即功能少、界面简单的版本，然后再对这个简单版本逐步进行改善（添加或修改功能）， 直至完全满足用户需求。初始精简版程序称为原型（prototype）。应用原型法来进行软件开 发的步骤大致如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）确认基本需求；</span><br><span class="line">（2）创建原型；</span><br><span class="line">（3）向用户演示或交付用户试用，获得反馈意见；</span><br><span class="line">（4）改善原型；回到（3），重复（3）、（4），直至用户最终认可。 可见，原型技术不是对整个问题按照“设计、实现、测试”的过程来开发，而是先按此</span><br></pre></td></tr></table></figure></p>
<p>4.螺旋式开发并不是用来取代自顶向下设计的，这两种设计方法是互为补充 的关系。</p>
<h3 id="三、并行计算"><a href="#三、并行计算" class="headerlink" title="三、并行计算"></a>三、并行计算</h3><h4 id="1-串行、并发与并行"><a href="#1-串行、并发与并行" class="headerlink" title="1.串行、并发与并行"></a>1.串行、并发与并行</h4><p>1.计算机执行程序时，如果采用按顺序执行的方式，即仅当一个程序执行完毕，下一个程序才能开始执行，则称为串行（serial）执行。</p>
<p>2.为了提高 CPU 的利用率，计算机可以采用这样的执行方式：当程序 P1 因为等待输入或 其他原因而暂时不用 CPU 时，CPU 就去执行另一个程序 P2；当 P1 结束输入时，CPU 再回 去继续执行 P1。</p>
<p>3.当然，如果计算机系统中有多个处理器（核心是 CPU），那么就可以做到真正的多个程 序“同时”执行，因为各 CPU 可以在同一时刻执行各自的指令。为了与单一 CPU 上的并发 相区别，我们称这种执行方式为并行（parallel）执行。</p>
<h4 id="2-进程与线程"><a href="#2-进程与线程" class="headerlink" title="2.进程与线程"></a>2.进程与线程</h4><p>1.操作系统控制处理器在多个程序之间切换执行的过程称为调度。</p>
<p>2.进程（process）是指程序的一次执行所形成的实体，每当程序 开始执行，就会创建一个进程。</p>
<p>3.注意，程序与进程是不同的概念。首先，不同程序在计算机中执行，自然形成不同的进 程。其次，即使是同一个程序，当它在计算机中多次执行时，也会创建多个不同进程，这些 进程虽然具有相同的程序代码，但各有自己的上下文。</p>
<p>4.多任务、多进程也有缺点。第一，实现多进程并发需要花费不少系统开销。因为 每创建一个进程都要为它分配一些内存，以便存储它的上下文；而操作系统在不同进程间进 行调度时需要保存和恢复进程上下文。第二，进程间通信比较困难。进程和进程是隔离的， 各进程拥有自己的地址空间，一个进程不能访问另一个进程的地址空间，从而在进程之间很 难共享信息。因此，对于两个需要传递信息的进程，相互通信很麻烦。</p>
<p>5.为了解决上述两个问题，产生了线程的概念。传统程序是从第一行指令一直执行到最后 一行指令，程序中只有一个控制流。这就像写小说时，沿着唯一的故事线索推进。而所谓线程（thread），是指程序中的一段代码，它构成程序中一个相对独立的执行单位。线程概念 使我们可以从一个程序中分出多个控制流来执行多个任务，所以线程实际上是程序内部的多 任务机制。就好比一部小说在叙述过程中，同时存在着多个故事线索，多头并进。</p>
<h4 id="3-多线程编程的应用"><a href="#3-多线程编程的应用" class="headerlink" title="3.多线程编程的应用"></a>3.多线程编程的应用</h4><p>1.多线程技术主要用于需要并发执行的场合。例如在很多游戏程序中，都需要维持一个动画场景，而玩家可以通过鼠标或键盘来输入操作指令，控制游戏的进行。</p>
<p>2.多线程技术涉及所谓竞态条件（race condition），即因为未曾预料到的、对事件之间 相对时序的严重依赖而导致的异常行为。具体例子如：两个客户同时登录订票网站，都看到 某航班还剩一个座位，于是都下单预定该座位，最终必然会因为谁先来后到而引起纠纷。如 果两人是在售票点排队购票（串行执行）就没有这个问题。因此，多线程程序与串行程序是 不同的，需要分析并协调各线程间的复杂的执行时序，这导致编程和调试都很困难。</p>
<h2 id="第十章-算法设计和分析"><a href="#第十章-算法设计和分析" class="headerlink" title="第十章 算法设计和分析"></a>第十章 算法设计和分析</h2><h3 id="一、枚举法"><a href="#一、枚举法" class="headerlink" title="一、枚举法"></a>一、枚举法</h3><p>采用枚举策略设计算法的一般步骤：</p>
<p>(1) 确定枚举对象、枚举范围和判定条件；</p>
<p>(2) 枚举各可能解，逐一验证是否所需的问题解。</p>
<p>(3) 尽量减小枚举范围，提高算法效率。</p>
<h3 id="二、递归"><a href="#二、递归" class="headerlink" title="二、递归"></a>二、递归</h3><p>递归是非常重要的算法设计方法，在解决很多具有递归性质的问题、结构的时候，设计<br>递归算法往往是直接而简单的。递归定义必须满足以下条件才是良定义的：</p>
<ul>
<li>有一个或多个无需递归的奠基情形；</li>
<li>递归总是针对规模更小的问题。</li>
<li><h3 id="三、分治法"><a href="#三、分治法" class="headerlink" title="三、分治法"></a>三、分治法</h3></li>
</ul>
<p>1.分治法（divide-and-conquer）是解决问题的一种常用策略，其思想是将难以处理的较大 问题分解为若干个较小的子问题，然后分别解决这些子问题，并从子问题的解构造出原问题 的解。“分”是指将原问题分解，“治”是指解决问题。</p>
<p>2.排序法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(1)选择排序法</span><br><span class="line"></span><br><span class="line">其思想是：先从全体 n 个数据 中找出最小值，并将该最小值排在第一个位置；然后从剩下的 n-1 个数据中再次找出最小值，这个最小值实</span><br><span class="line">际上是全体数据的次小值，我们将它排在第二个位置；依此类推，直至从剩下 的 2 个数据中找出最小值，排在第 n-1 个位置，而剩下的最后一个数据（全体数据中的最大 值）可以直接排在第 n 个位置。</span><br><span class="line"></span><br><span class="line">（2）归并排序</span><br><span class="line"></span><br><span class="line">给定一个较大的数据集合 S，先将数据平分为两部分 S1 和 S2，然后分别对 S1 和 S2 进行 排序，从而得到两个“局部有序”的序列。接下去将这两</span><br><span class="line">个局部有序序列合并成为“全局有 序”序列，这个过程称为归并（merge）。</span><br></pre></td></tr></table></figure></p>
<h3 id="四、贪心法"><a href="#四、贪心法" class="headerlink" title="四、贪心法"></a>四、贪心法</h3><p>1.贪心法指的是这样一种问题求解策 略：在求解过程的每一步都尽量作出在当前情况下局部最优的选择，以期最终能得到全局最 优解。</p>
<p>2.当然，好的棋手是不会采用贪心策略来下棋的，他们会计算未来的很多步棋，然后选择 全局最优的着法。这说明贪心策略只能对某些问题（如上述最小支撑树问题）能产生全局最 优解，对另一些问题则不然。不过，贪心算法的优点是能够较快地找出解法，产生的结果经 常也是接近全局最优解的；而一心追求全局最优解则有可能导致无法在合理的时间内达到目 标，就像棋手如果指望算无遗策，那就要花费大量时间来计算着法，这几乎是不可能的。</p>
<h3 id="五、算法分析"><a href="#五、算法分析" class="headerlink" title="五、算法分析"></a>五、算法分析</h3><h4 id="1-算法复杂度"><a href="#1-算法复杂度" class="headerlink" title="1.算法复杂度"></a>1.算法复杂度</h4><p>1.算法通常都设计成能处理任意大小的输入数据，这就导致算法的步数并不是固定的，而 是随着问题规模的变化而变化，因此算法的步数可表示为问题规模的函数。</p>
<p>2.在描述算法复杂度时，n 对应于问题规模，f(n)是算法需执行的步数，g(n)是表示增长数 量级的某个函数。说算法的复杂度为 O(g(n))，意思就是当 n 足够大时，该算法的执行步数（时间）永远不会超过 c×g(n)。</p>
<h4 id="2-算法分析实例"><a href="#2-算法分析实例" class="headerlink" title="2.算法分析实例"></a>2.算法分析实例</h4><p>1.线性搜索：线性搜索算法的思想是逐个检查列表成员，编码时可以用一个循环语句来实现。线性搜索算法在最坏情形下的运行时间与输入列表的大小 n 呈线性关系，即复杂度为 O(n)，称为线性时间算法。</p>
<p>2.二分搜索算法的主体也是一个循环，但该循环不是逐个检查列表数据，而是每次检查位 于列表中点的数据，并根据该中点数据与要查找的数据的大小比较情况来排除掉左半列表或 右半列表。</p>
<h4 id="六、不可计算问题"><a href="#六、不可计算问题" class="headerlink" title="六、不可计算问题"></a>六、不可计算问题</h4><p>1.图灵机</p>
<p>英国数学家 Alan Turing 于 1936 年发明了一种抽象机器用于研究计算的本质，人们称这 种机器为图灵机（Turing machine）。图灵机能够模拟算法式计算，即按预定的规则一步一步 执行基本指令的过程。现代计算机就是这样按照预定的程序一步一步执行指令的，因此可以 视为图灵机的具体实现。</p>
<p>图灵机的强大计算能力有一个重要表现，那就是一个图灵机可以模拟另一个图灵机的工 作。</p>
<h2 id="第11章-计算-X"><a href="#第11章-计算-X" class="headerlink" title="第11章 计算+X"></a>第11章 计算+X</h2><p>1.当代科学研究有三大支柱：理论、实验和计算。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/微机原理/">微机原理</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/微机原理/">微机原理</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://yoursite.com/2018/10/06/程序设计思想与方法/" data-title="程序设计思想与方法 | 闳" data-tsina="" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2018/10/06/C入门笔记/" title="C++入门笔记">
  <strong>上一篇：</strong><br/>
  <span>
  C++入门笔记</span>
</a>
</div>


</nav>

	



</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#第一章-计算与计算思维"><span class="toc-number">1.</span> <span class="toc-text">第一章 计算与计算思维</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、计算机语言"><span class="toc-number">1.1.</span> <span class="toc-text">一、计算机语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、算法"><span class="toc-number">1.2.</span> <span class="toc-text">二、算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、计算思维的的基本原则"><span class="toc-number">1.3.</span> <span class="toc-text">三、计算思维的的基本原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第三章-数据处理的流程控制"><span class="toc-number">2.</span> <span class="toc-text">第三章 数据处理的流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、循序控制结构"><span class="toc-number">2.1.</span> <span class="toc-text">一、循序控制结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、异常处理"><span class="toc-number">2.2.</span> <span class="toc-text">二、异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、结构化程序设计"><span class="toc-number">2.3.</span> <span class="toc-text">三、结构化程序设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第四章-模块化编程"><span class="toc-number">3.</span> <span class="toc-text">第四章 模块化编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、模块化编程基本概念"><span class="toc-number">3.1.</span> <span class="toc-text">一、模块化编程基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、自顶向下设计"><span class="toc-number">3.2.</span> <span class="toc-text">二、自顶向下设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、自底向上实现与单元测试"><span class="toc-number">3.3.</span> <span class="toc-text">三、自底向上实现与单元测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第六章-大量数据的表示和处理"><span class="toc-number">4.</span> <span class="toc-text">第六章 大量数据的表示和处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、简单数据和复杂数据"><span class="toc-number">4.1.</span> <span class="toc-text">一、简单数据和复杂数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、几种高级数据结构"><span class="toc-number">4.2.</span> <span class="toc-text">二、几种高级数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第七章-面向对象思想与编程"><span class="toc-number">5.</span> <span class="toc-text">第七章 面向对象思想与编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、数据与操作：两种观点"><span class="toc-number">5.1.</span> <span class="toc-text">一、数据与操作：两种观点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、面向过程的观点"><span class="toc-number">5.1.1.</span> <span class="toc-text">1、面向过程的观点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、面向对象观点"><span class="toc-number">5.1.2.</span> <span class="toc-text">2、面向对象观点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-类是类型概念的发展"><span class="toc-number">5.1.3.</span> <span class="toc-text">3.类是类型概念的发展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、面向对象的编程"><span class="toc-number">5.2.</span> <span class="toc-text">二、面向对象的编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-类的定义"><span class="toc-number">5.2.1.</span> <span class="toc-text">1.类的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-对象的创建"><span class="toc-number">5.2.2.</span> <span class="toc-text">2.对象的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-对象的调用"><span class="toc-number">5.2.3.</span> <span class="toc-text">3.对象的调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-类与模块化"><span class="toc-number">5.2.4.</span> <span class="toc-text">4.类与模块化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-对象的集合体"><span class="toc-number">5.2.5.</span> <span class="toc-text">5.对象的集合体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、超类与子类"><span class="toc-number">5.3.</span> <span class="toc-text">三、超类与子类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-继承"><span class="toc-number">5.3.1.</span> <span class="toc-text">1.继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-复写"><span class="toc-number">5.3.2.</span> <span class="toc-text">2.复写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-多态性"><span class="toc-number">5.3.3.</span> <span class="toc-text">3.多态性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、面向对象的设计"><span class="toc-number">5.4.</span> <span class="toc-text">四、面向对象的设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第八章-图形用户界面"><span class="toc-number">6.</span> <span class="toc-text">第八章 图形用户界面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、图形用户界面概述"><span class="toc-number">6.1.</span> <span class="toc-text">一、图形用户界面概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、GUI编程"><span class="toc-number">6.2.</span> <span class="toc-text">二、GUI编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GUI-编程一般需要如下几个步骤："><span class="toc-number">6.2.1.</span> <span class="toc-text">GUI 编程一般需要如下几个步骤：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#框架"><span class="toc-number">6.2.2.</span> <span class="toc-text">框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#布局"><span class="toc-number">6.2.3.</span> <span class="toc-text">布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对话框"><span class="toc-number">6.2.4.</span> <span class="toc-text">对话框</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事件处理"><span class="toc-number">6.2.5.</span> <span class="toc-text">事件处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#键盘事件与焦点"><span class="toc-number">6.2.6.</span> <span class="toc-text">键盘事件与焦点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、模型-视图设计方法"><span class="toc-number">6.3.</span> <span class="toc-text">三、模型-视图设计方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-将-GUI-应用程序封装成对象"><span class="toc-number">6.3.1.</span> <span class="toc-text">1.将 GUI 应用程序封装成对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-模型与视图"><span class="toc-number">6.3.2.</span> <span class="toc-text">2.模型与视图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第九章-模拟开发与并发"><span class="toc-number">7.</span> <span class="toc-text">第九章 模拟开发与并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、模拟"><span class="toc-number">7.1.</span> <span class="toc-text">一、模拟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、原型法"><span class="toc-number">7.2.</span> <span class="toc-text">二、原型法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、并行计算"><span class="toc-number">7.3.</span> <span class="toc-text">三、并行计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-串行、并发与并行"><span class="toc-number">7.3.1.</span> <span class="toc-text">1.串行、并发与并行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-进程与线程"><span class="toc-number">7.3.2.</span> <span class="toc-text">2.进程与线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-多线程编程的应用"><span class="toc-number">7.3.3.</span> <span class="toc-text">3.多线程编程的应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第十章-算法设计和分析"><span class="toc-number">8.</span> <span class="toc-text">第十章 算法设计和分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、枚举法"><span class="toc-number">8.1.</span> <span class="toc-text">一、枚举法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、递归"><span class="toc-number">8.2.</span> <span class="toc-text">二、递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、分治法"><span class="toc-number">8.3.</span> <span class="toc-text">三、分治法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、贪心法"><span class="toc-number">8.4.</span> <span class="toc-text">四、贪心法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五、算法分析"><span class="toc-number">8.5.</span> <span class="toc-text">五、算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-算法复杂度"><span class="toc-number">8.5.1.</span> <span class="toc-text">1.算法复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-算法分析实例"><span class="toc-number">8.5.2.</span> <span class="toc-text">2.算法分析实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#六、不可计算问题"><span class="toc-number">8.5.3.</span> <span class="toc-text">六、不可计算问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第11章-计算-X"><span class="toc-number">9.</span> <span class="toc-text">第11章 计算+X</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/2018Dian团队年终茶话会/" title="2018Dian团队年终茶话会">2018Dian团队年终茶话会<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android/" title="Android">Android<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/C/" title="C++">C++<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java学习/" title="Java学习">Java学习<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/Linux学习/" title="Linux学习">Linux学习<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/SQL学习/" title="SQL学习">SQL学习<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/git学习/" title="git学习">git学习<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/微机原理/" title="微机原理">微机原理<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/操作系统/" title="操作系统">操作系统<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/敏捷开发/" title="敏捷开发">敏捷开发<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/文学/" title="文学">文学<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/机器学习/" title="机器学习">机器学习<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/材料物理化学/" title="材料物理化学">材料物理化学<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/深信服/" title="深信服">深信服<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/网安组/" title="网安组">网安组<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/苏秦任务指导/" title="苏秦任务指导">苏秦任务指导<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/计算机网络/" title="计算机网络">计算机网络<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/讲座分享/" title="讲座分享">讲座分享<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/讲座培训/" title="讲座培训">讲座培训<sup>2</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/数据结构/" title="数据结构">数据结构<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/计算机网络/" title="计算机网络">计算机网络<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Linux/" title="Linux">Linux<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/操作系统/" title="操作系统">操作系统<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Dian/" title="Dian">Dian<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/微机原理/" title="微机原理">微机原理<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/材料物理化学/" title="材料物理化学">材料物理化学<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/机器学习/" title="机器学习">机器学习<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/网络安全/" title="网络安全">网络安全<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Android/" title="Android">Android<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/散文/" title="散文">散文<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/深信服/" title="深信服">深信服<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/节目策划/" title="节目策划">节目策划<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/git/" title="git">git<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Java-虚拟机/" title="Java 虚拟机">Java 虚拟机<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/对分易/" title="对分易">对分易<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C/" title="Objective-C">Objective-C<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/敏捷开发/" title="敏捷开发">敏捷开发<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/感悟/" title="感悟">感悟<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2019 
		
		<a href="/about" target="_blank" title="柳柳">柳柳</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>











<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
